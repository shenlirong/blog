"use strict";(self.webpackChunktest3=self.webpackChunktest3||[]).push([[9958],{6262:(t,e)=>{e.A=(t,e)=>{const l=t.__vccOpts||t;for(const[t,r]of e)l[t]=r;return l}},9958:(t,e,l)=>{l.r(e),l.d(e,{default:()=>o});var r=l(641);const a={class:"marklang"},d={},o=(0,l(6262).A)(d,[["render",function(t,e){return(0,r.uX)(),(0,r.CE)("div",a,e[0]||(e[0]=[(0,r.Lk)("p",{class:"marklang-paragraph"},[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"ref需要使用.value来访问和更新数据，而reactive不需要，主要原因在于它们处理数据的方式不同。"),(0,r.eW)("‌")],-1),(0,r.Lk)("h3",null,"ref和reactive的基本概念和区别",-1),(0,r.Lk)("ol",null,[(0,r.Lk)("li",null,[(0,r.Lk)("p",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"ref"),(0,r.eW)("‌：")]),(0,r.Lk)("ul",null,[(0,r.Lk)("li",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"数据类型"),(0,r.eW)("‌ref可以处理基础数据类型（如字符串、数字、布尔值）和复杂数据类型（如对象）。")]),(0,r.Lk)("li",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"访问方式"),(0,r.eW)("‌：无论是基础数据类型还是对象，访问数据都需要通过"),(0,r.Lk)("code",null,".value"),(0,r.eW)("形式进行，更新数据也需要通过"),(0,r.Lk)("code",null,".value"),(0,r.eW)("来更新。但在"),(0,r.Lk)("code",null,"<template>"),(0,r.eW)("中使用ref的值时不需要带上"),(0,r.Lk)("code",null,".value"),(0,r.eW)("。 ")]),(0,r.Lk)("li",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"内部实现"),(0,r.eW)("‌：ref内部本质上是调用了reactive方法，将传入的对象转换成具有深层次的响应式对象‌"),(0,r.Lk)("span",{"disable-audio":"true","disable-copy":"true"},[(0,r.Lk)("span",{"rl-type":"stop"},[(0,r.Q3)("860"),(0,r.Lk)("span",{class:"cos-tooltip cosd-citation"},[(0,r.Q3)("863"),(0,r.Lk)("span",{class:"cosd-citation-citationId"},[(0,r.eW)("1"),(0,r.Q3)("864")]),(0,r.Q3)("863")]),(0,r.Q3)("861"),(0,r.Q3)("865"),(0,r.Q3)("865"),(0,r.Q3)("860")]),(0,r.Lk)("span",{"rl-type":"stop"},[(0,r.Q3)("867"),(0,r.Lk)("span",{class:"cos-tooltip cosd-citation"},[(0,r.Q3)("870"),(0,r.Lk)("span",{class:"cosd-citation-citationId"},[(0,r.eW)("2"),(0,r.Q3)("871")]),(0,r.Q3)("870")]),(0,r.Q3)("868"),(0,r.Q3)("872"),(0,r.Q3)("872"),(0,r.Q3)("867")])]),(0,r.eW)("。 ")])])]),(0,r.Lk)("li",null,[(0,r.Lk)("p",{class:"marklang-paragraph"},[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"reactive"),(0,r.eW)("‌：")]),(0,r.Lk)("ul",null,[(0,r.Lk)("li",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"数据类型"),(0,r.eW)("‌：仅处理复杂数据类型（如对象），不允许传递基础类型的值。")]),(0,r.Lk)("li",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"访问方式"),(0,r.eW)("‌：直接访问对象的属性，不需要通过额外的"),(0,r.Lk)("code",null,".value"),(0,r.eW)("。")]),(0,r.Lk)("li",null,[(0,r.eW)("‌"),(0,r.Lk)("strong",null,"内部实现"),(0,r.eW)("‌：基于ES6的Proxy对象，通过拦截属性的获取和设置操作来实现响应式‌"),(0,r.Lk)("span",{"disable-audio":"true","disable-copy":"true"},[(0,r.Lk)("span",{"rl-type":"stop"},[(0,r.Q3)("874"),(0,r.Lk)("span",{class:"cos-tooltip cosd-citation"},[(0,r.Q3)("877"),(0,r.Lk)("span",{class:"cosd-citation-citationId"},[(0,r.eW)("2"),(0,r.Q3)("878")]),(0,r.Q3)("877")]),(0,r.Q3)("875"),(0,r.Q3)("879"),(0,r.Q3)("879"),(0,r.Q3)("874")]),(0,r.Lk)("span",{"rl-type":"stop"},[(0,r.Q3)("881"),(0,r.Lk)("span",{class:"cos-tooltip cosd-citation"},[(0,r.Q3)("884"),(0,r.Lk)("span",{class:"cosd-citation-citationId"},[(0,r.eW)("3"),(0,r.Q3)("885")]),(0,r.Q3)("884")]),(0,r.Q3)("882"),(0,r.Q3)("886"),(0,r.Q3)("886"),(0,r.Q3)("881")])]),(0,r.eW)("。 ")])])])],-1),(0,r.Fv)('<h3>为什么ref需要.value而reactive不需要</h3><ol><li><p class="marklang-paragraph">‌<strong>设计哲学</strong>‌：</p><ul><li>‌<strong>ref的设计</strong>‌：ref的设计初衷是为了替代Vue 2中的data属性，能够更好地与Vue 2的迁移兼容。通过<code>.value</code>访问和更新数据，使得代码更加直观和易于理解。</li><li>‌<strong>reactive的设计</strong>‌：由于reactive仅处理对象，且不涉及基础数据类型的处理，因此直接访问对象的属性即可，无需额外的语法。</li></ul></li><li><p class="marklang-paragraph">‌<strong>使用场景</strong>‌：</p><ul><li>‌<strong>ref</strong>‌：适用于需要处理基础数据类型和复杂数据类型的场景，提供了一种统一的处理方式。</li><li>‌<strong>reactive</strong>‌：适用于仅处理复杂数据类型的场景，由于其不支持基础数据类型，使用起来更为简单直接。</li></ul></li></ol><h3>总结对比表</h3><table><thead><tr><th>‌<strong>场景</strong>‌</th><th>‌<strong>推荐使用</strong>‌</th><th>‌<strong>原因</strong>‌</th></tr></thead><tbody><tr><td>基本类型数据</td><td><code>ref</code></td><td><code>reactive</code>不支持基本类型</td></tr><tr><td>DOM/组件引用</td><td><code>ref</code></td><td><code>reactive</code>无法直接绑定模板引用</td></tr><tr><td>整体替换对象</td><td><code>ref</code></td><td><code>reactive</code>替换会丢失响应式</td></tr><tr><td>明确的值传递语义</td><td><code>ref</code></td><td><code>.value</code>提供清晰接口</td></tr><tr><td>独立状态管理</td><td><code>ref</code></td><td>代码更简洁，避免不必要的对象嵌套</td></tr></tbody></table><h2>reactive和 ref 对比</h2><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td>reactive</td><td>ref</td></tr><tr><td>❌ 只支持对象和数组（引用数据类型）</td><td>✅ 支持基本数据类型 + 引用数据类型</td></tr><tr><td>✅ 在 &lt;script&gt; 和 &lt;template&gt; 中无差别使用</td><td>❌ 在 &lt;script&gt; 和 &lt;template&gt; 使用方式不同（在 &lt;script&gt; 中要使用 .value）</td></tr><tr><td>❌ 重新分配一个新对象会丢失响应性</td><td>✅ 重新分配一个新对象不会失去响应</td></tr><tr><td>能直接访问属性</td><td>需要使用 .value 访问属性</td></tr><tr><td>❌ 将对象传入函数时，失去响应</td><td>✅ 传入函数时，不会失去响应</td></tr><tr><td>❌ 解构时会丢失响应性，需使用 toRefs</td><td>❌ 解构对象时会丢失响应性，需使用 toRefs</td></tr></tbody></table><ul><li data-pid="hAQZ1bD2">ref 用于将基本类型的数据和引用数据类型（对象）转换为响应式数据，通过 .value 访问和修改。</li><li data-pid="elEbqWxx">reactive 用于将对象转换为响应式数据，可以直接访问和修改属性，适用于复杂的嵌套对象和数组。</li></ul>',7)]))}]])}}]);