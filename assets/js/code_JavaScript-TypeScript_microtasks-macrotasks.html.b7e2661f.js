"use strict";(self.webpackChunktest3=self.webpackChunktest3||[]).push([[2563],{7881:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>l,data:()=>t});var n=a(641);const e={},l=(0,a(6262).A)(e,[["render",function(s,i){return(0,n.uX)(),(0,n.CE)("div",null,[(0,n.Q3)(" more "),i[0]||(i[0]=(0,n.Fv)('<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>事件循环机制中 <strong>微任务和宏任务</strong> 的差异主要由 <strong>执行机制和设计目标</strong> 决定：</p><p><strong>1.微任务设计初衷</strong><br> 微任务设计初衷是为解决特定场景需求，例如Promise的回调执行、process.nextTick()等，这些任务通常需要快速完成且不影响其他异步操作，因此采用单队列处理模式。 ‌</p><p><strong>2.宏任务特性</strong><br> 宏任务涉及更复杂的操作（如定时器、文件读写、UI渲染等），需要更灵活的调度机制。浏览器或环境会为不同类型宏任务维护独立队列，例如定时器队列、I/O操作队列等，但执行时仍遵循先进先出原则。 ‌</p><p><strong>3.执行优先级差异</strong><br> 微任务优先级高于宏任务，每次宏任务执行后都会优先处理所有微任务，确保异步操作不会阻塞主线程。这种设计既保证响应性又维持任务处理的独立性</p></div>',1)),(0,n.Q3)(" more "),i[1]||(i[1]=(0,n.Fv)('<h1 id="微任务与宏任务" tabindex="-1"><a class="header-anchor" href="#微任务与宏任务"><span>微任务与宏任务</span></a></h1><p>在JavaScript异步编程中，微任务（Microtasks）和宏任务（Macrotasks） 是两种不同优先级的任务队列，共同构成了事件循环（Event Loop）的核心机制。理解它们的区别对掌握异步执行顺序至关重要。</p><p>宏任务和微任务都是JavaScript异步任务中的概念。它们都是指那些会在将来某个时刻执行的代码。区别在于执行时机和优先级。</p><p><strong>微任务（Microtask） 是JavaScript引擎自身产生的任务，优先级更高。</strong> 在当前任务（也就是执行栈）结束后，JavaScript引擎会立即处理所有微任务队列中的任务，清空微任务队列后才会执行浏览器渲染或处理下一个宏任务。常见的微任务包括：Promise的回调函数（then/catch/finally）、MutationObserver（监测DOM变化的接口）以及queueMicrotask API添加的任务。</p><p><strong>宏任务（Macrotask）则是由宿主环境（浏览器或Node.js）发起的任务，优先级相对较低。</strong> 包括setTimeout、setInterval的回调、I/O操作（如文件读写、网络请求）、UI渲染（浏览器）、setImmediate（Node.js）、requestAnimationFrame（浏览器）等。事件循环的每一轮（称为一次tick），只会执行一个宏任务，然后就去处理所有的微任务。</p><p><strong>​为什么微任务优先级更高？​​</strong><br> 微任务为JavaScript引擎内部任务，需要在渲染更新前完成所有状态变更。</p><p><strong>总结关键点：</strong></p><ul><li>微任务由JS引擎管理，宏任务由宿主环境管理。</li><li>每个事件循环中，总是先执行当前执行栈中的同步代码。</li><li>接着执行所有微任务（清空微任务队列）。</li><li>然后进行渲染（浏览器环境下），之后取一个宏任务执行。</li><li>宏任务执行后再次执行所有微任务，依此循环。<br> 这种机制保证了微任务可以尽快执行，而宏任务则按顺序一个接一个地执行（在每个宏任务之间，引擎都去处理微任务和可能的渲染）</li></ul><h3 id="一、微任务-microtasks" tabindex="-1"><a class="header-anchor" href="#一、微任务-microtasks"><span>一、微任务（Microtasks）</span></a></h3><p>定义：<br> 由JavaScript引擎自身调度的高优先级任务，必须在浏览器渲染前完全执行完毕。<br> 典型来源：</p><ol><li>Promise回调</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;微任务 - Promise回调&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>queueMicrotask()</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queueMicrotask</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;微任务 - queueMicrotask&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>MutationObserver（监听DOM变化）</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MutationObserver</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;DOM改变了&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">observe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>Node.js环境特有<br> process.nextTick()（Node.js中优先级最高）<br> 核心特性：<br> ✅ 插队执行：在前一个宏任务结束、下一个宏任务开始前必须清空所有微任务<br> ✅ 高优先级：阻塞浏览器渲染（如执行100个微任务时页面会卡住）<br> ✅ 单队列：整个事件循环只有一个微任务队列</li></ol><hr><h3 id="二、宏任务-macrotasks" tabindex="-1"><a class="header-anchor" href="#二、宏任务-macrotasks"><span>二、宏任务（Macrotasks）</span></a></h3><p>定义：<br> 由宿主环境（浏览器/Node.js）管理的常规异步任务，每次事件循环只执行一个。<br> 典型来源：</p><ol><li>定时器相关</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - setTimeout&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setInterval</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - setInterval&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>I/O操作</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">fetch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;/data&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">res</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - 网络请求完成&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>UI渲染（浏览器特有）</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">requestAnimationFrame</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - 渲染回调&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>脚本执行</li></ol><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-html"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - 脚本执行&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">script</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>事件回调</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">button</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;click&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - 点击事件&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>Node.js环境特有<br> setImmediate()（比setTimeout(fn,0)优先级更高）<br> 核心特性：<br> ⏳ 排队执行：事件循环每轮只执行一个宏任务<br> 🚦 低优先级：执行后会让出控制权给微任务队列<br> 📚 多队列：存在不同的宏任务队列（如定时器队列、网络请求队列等）</li></ol><hr><h3 id="三、执行流程演示" tabindex="-1"><a class="header-anchor" href="#三、执行流程演示"><span>三、执行流程演示</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;同步任务开始&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 宏任务</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;宏任务 - setTimeout&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 微任务</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;微任务 - Promise&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;同步任务结束&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="执行顺序解析" tabindex="-1"><a class="header-anchor" href="#执行顺序解析"><span>执行顺序解析：</span></a></h4><ol><li>同步任务开始 → 同步任务最先执行</li><li>同步任务结束 → 继续执行同步代码</li><li>微任务 - Promise → 所有微任务必须立刻执行</li><li>宏任务 - setTimeout → 最后执行宏任务</li></ol><h4 id="输出顺序" tabindex="-1"><a class="header-anchor" href="#输出顺序"><span>输出顺序：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>同步任务开始</span></span>\n<span class="line"><span>同步任务结束</span></span>\n<span class="line"><span>微任务 - Promise</span></span>\n<span class="line"><span>宏任务 - setTimeout</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="四、事件循环中的执行模型" tabindex="-1"><a class="header-anchor" href="#四、事件循环中的执行模型"><span>四、事件循环中的执行模型</span></a></h3><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-mermaid"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">flowchart TB</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    A[执行栈] --&gt; B{栈空?}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    B --&gt;|是| C[执行所有微任务]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    C --&gt; D{微任务队列空?}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    D --&gt;|是| E[渲染更新&lt;br&gt;浏览器环境特有]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    E --&gt; F[取一个宏任务执行]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    F --&gt; A</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="关键规则" tabindex="-1"><a class="header-anchor" href="#关键规则"><span>关键规则：</span></a></h4><ol><li>微任务优先：每执行完一个宏任务后，必须清空整个微任务队列</li><li>微任务会创建微任务：微任务执行过程中再添加的新微任务会被继续执行，导致死循环风险</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> infiniteMicrotask</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">infiniteMicrotask</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 页面卡死！</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>宏任务分级：不同宏任务类型有优先级差异（如setImmediate &gt; setTimeout）</li></ol><hr><h3 id="五、实际应用场景对比" tabindex="-1"><a class="header-anchor" href="#五、实际应用场景对比"><span>五、实际应用场景对比</span></a></h3><table><thead><tr><th>场景</th><th>推荐使用</th><th>原因</th></tr></thead><tbody><tr><td>异步状态更新</td><td>微任务</td><td>在渲染前完成DOM状态变更（如Vue.nextTick）</td></tr><tr><td>批量数据处理</td><td>微任务</td><td>避免中间状态被渲染</td></tr><tr><td>耗时操作（如大数组处理）</td><td>宏任务</td><td>用setTimeout(fn,0)分片执行避免阻塞</td></tr><tr><td>动画处理</td><td>宏任务 + requestAnimationFrame</td><td>保持与浏览器刷新率同步</td></tr><tr><td>高精度定时</td><td>微任务 + 递归</td><td>通过微任务链实现比4ms更精确的调度（特殊场景）</td></tr></tbody></table><blockquote><p>💡 核心记忆点：<br> 微任务如VIP通道（插队执行），宏任务如普通队列（按序等候）。当一段同步代码结束，JS引擎会立刻处理所有微任务（清空队列），然后才执行下一个宏任务或渲染页面。</p></blockquote><h2 id="宏任务与微任务的区别" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务的区别"><span>宏任务与微任务的区别</span></a></h2><p>我们要解释宏任务（macrotask）和微任务（microtask）的区别。这是JavaScript事件循环中的两个重要概念。<br><strong>宏任务包括：</strong> script（整体代码）、setTimeout、setInterval、I/O操作、UI渲染、setImmediate（Node.js环境）等。<br><strong>微任务包括：</strong> Promise回调、MutationObserver、process.nextTick（Node.js环境）等。<br><strong>关键区别在于事件循环的处理方式：</strong></p><p>1.事件循环中，每次执行一个宏任务（从宏任务队列中取出一个任务执行）。<br> 2.在该宏任务执行完毕后，会立即执行当前微任务队列中的所有微任务（直到微任务队列为空）。<br> 3.然后进行UI渲染（如果需要），接着再取下一个宏任务执行。</p><p>因此，微任务会在下一个宏任务之前执行，也就是说微任务有更高的优先级。</p><p>示例代码：</p><div class="language- line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="" style="--vp-collapsed-lines:15;--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>console.log(&#39;1&#39;);</span></span>\n<span class="line"><span>setTimeout(() =&gt; { console.log(&#39;2&#39;); }, 0);</span></span>\n<span class="line"><span>Promise.resolve().then(() =&gt; { console.log(&#39;3&#39;); });</span></span>\n<span class="line"><span>console.log(&#39;4&#39;);</span></span>\n<span class="line"><span>输出顺序是：1, 4, 3, 2</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>首先，整个script作为一个宏任务执行，输出1和4。</span></span>\n<span class="line"><span>然后，执行当前宏任务中的微任务（Promise回调），输出3。</span></span>\n<span class="line"><span>接着，下一个宏任务（setTimeout）执行，输出2。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>另一个更复杂的例子：</span></span>\n<span class="line"><span>console.log(&#39;1&#39;);</span></span>\n<span class="line"><span>setTimeout(function() {</span></span>\n<span class="line"><span>console.log(&#39;2&#39;);</span></span>\n<span class="line"><span>new Promise(function(resolve) {</span></span>\n<span class="line"><span>console.log(&#39;3&#39;);</span></span>\n<span class="line"><span>resolve();</span></span>\n<span class="line"><span>}).then(function() {</span></span>\n<span class="line"><span>console.log(&#39;4&#39;);</span></span>\n<span class="line"><span>});</span></span>\n<span class="line"><span>}, 0);</span></span>\n<span class="line"><span>new Promise(function(resolve) {</span></span>\n<span class="line"><span>console.log(&#39;5&#39;);</span></span>\n<span class="line"><span>resolve();</span></span>\n<span class="line"><span>}).then(function() {</span></span>\n<span class="line"><span>console.log(&#39;6&#39;);</span></span>\n<span class="line"><span>});</span></span>\n<span class="line"><span>console.log(&#39;7&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><p>输出顺序：1, 5, 7, 6, 2, 3, 4<br> 解释：</p><p>第一个宏任务（整体代码）：<br> console.log(&#39;1&#39;) =&gt; 1<br> 遇到setTimeout，将其回调加入宏任务队列。<br> 执行Promise的构造函数，输出5，并将then的回调加入微任务队列。<br> console.log(&#39;7&#39;) =&gt; 7<br> 然后执行微任务队列：输出6。<br> 下一个宏任务（setTimeout的回调）：<br> console.log(&#39;2&#39;) =&gt; 2<br> 执行Promise构造函数，输出3，并将then的回调加入微任务队列。<br> 然后执行微任务队列（当前宏任务执行完毕后）：输出4。</p><p>因此，顺序是1,5,7,6,2,3,4。<br><strong>总结：</strong><br><strong>宏任务：</strong> 由宿主（浏览器、Node）发起的任务，如事件回调、网络请求完成回调、定时器等。<br><strong>微任务：</strong> 由JavaScript自身发起的任务，如Promise、MutationObserver等，通常用于异步操作，且优先级高于宏任务。<br> 注意：在同一个事件循环中，微任务总是在下一个宏任务之前执行完毕。</p><h1 id="javascript事件循环机制-宏任务与微任务详解" tabindex="-1"><a class="header-anchor" href="#javascript事件循环机制-宏任务与微任务详解"><span>JavaScript事件循环机制：宏任务与微任务详解</span></a></h1><h2 id="宏任务-macrotasks-与微任务-microtasks-的区别" tabindex="-1"><a class="header-anchor" href="#宏任务-macrotasks-与微任务-microtasks-的区别"><span>宏任务（Macrotasks）与微任务（Microtasks）的区别</span></a></h2><table><thead><tr><th>特性</th><th>宏任务 (Macrotask)</th><th>微任务 (Microtask)</th></tr></thead><tbody><tr><td>定义</td><td>JavaScript引擎外部的任务</td><td>JavaScript引擎内部的任务</td></tr><tr><td>执行时机</td><td>每个事件循环轮次中执行一次</td><td>在每个宏任务执行后立即执行</td></tr><tr><td>优先级</td><td>较低</td><td>较高（插队执行）</td></tr><tr><td>包含任务类型</td><td>setTimeout, setInterval, I/O操作, UI渲染, setImmediate(Node), requestAnimationFrame</td><td>Promise回调, MutationObserver, process.nextTick(Node), queueMicrotask</td></tr><tr><td>任务队列</td><td>一个事件循环可以有多个宏任务队列（如计时器队列、I/O队列等）</td><td>一个事件循环只有一个微任务队列</td></tr><tr><td>运行机制</td><td>&quot;尽最大努力&quot;按添加顺序执行</td><td>必须完全清空队列才会继续</td></tr><tr><td>代码控制</td><td>需要宿主环境API</td><td>可直接在JavaScript中创建</td></tr></tbody></table><h2 id="理解事件循环-event-loop-机制" tabindex="-1"><a class="header-anchor" href="#理解事件循环-event-loop-机制"><span>理解事件循环（Event Loop）机制</span></a></h2><p>JavaScript的事件循环机制遵循以下基本流程：<br> 1.执行当前调用栈中的所有同步代码<br> 2.执行当前微任务队列中的所有任务（直到队列清空）<br> 3.执行浏览器渲染更新（如果需要）<br> 4.从宏任务队列中取出一个任务执行<br> 5.重复步骤1-4</p><h2 id="代码示例分析" tabindex="-1"><a class="header-anchor" href="#代码示例分析"><span>代码示例分析</span></a></h2><div class="language-javascript line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="javascript" style="--vp-collapsed-lines:15;--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;1. 同步任务 - 开始&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;6. 宏任务 - setTimeout回调&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;4. 微任务 - Promise回调1&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  })</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;5. 微任务 - Promise回调2&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queueMicrotask</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;3. 微任务 - queueMicrotask&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2. 同步任务 - 结束&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h3 id="输出顺序分析" tabindex="-1"><a class="header-anchor" href="#输出顺序分析"><span>输出顺序分析：</span></a></h3><p><strong>1.同步任务 - 开始</strong> (第一个同步输出)<br><strong>2.同步任务 - 结束</strong> (最后一个同步输出)<br><strong>3.微任务 - queueMicrotask</strong> (微任务队列中先添加)<br><strong>4.微任务 - Promise回调1</strong> (微任务队列中后添加)<br><strong>5.微任务 - Promise回调2</strong> (微任务队列中添加)<br><strong>6.宏任务 - setTimeout回调</strong> (宏任务队列中的任务)</p><div class="language-mermaid line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="mermaid" style="--vp-collapsed-lines:15;--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-mermaid"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">graph TD</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    A[开始] --&gt; B[同步任务]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    B --&gt; C[宏任务队列添加 setTimeout]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    B --&gt; D[微任务队列添加 Promise回调]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    B --&gt; E[微任务队列添加 queueMicrotask]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    B --&gt; F[同步任务结束]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    F --&gt; G[执行所有微任务]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    G --&gt; H[queueMicrotask执行]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    G --&gt; I[Promise回调1执行]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    G --&gt; J[添加新的微任务 Promise回调2]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    G --&gt; K[执行新增的微任务 Promise回调2]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    K --&gt; L[微任务队列清空]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    L --&gt; M[检查宏任务队列]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    M --&gt; N[执行setTimeout回调]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    N --&gt; O[结束]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h2 id="实际应用场景" tabindex="-1"><a class="header-anchor" href="#实际应用场景"><span>实际应用场景</span></a></h2><h3 id="宏任务应用场景" tabindex="-1"><a class="header-anchor" href="#宏任务应用场景"><span>宏任务应用场景：</span></a></h3><p>(1) 延迟执行代码（setTimeout, setInterval)<br> (2) 大量数据分批处理（分时处理）<br> (3) 非关键UI更新<br> (4) 跨文档通信</p><h3 id="微任务应用场景" tabindex="-1"><a class="header-anchor" href="#微任务应用场景"><span>微任务应用场景：</span></a></h3><p>(1) Promise异步流程控制<br> (2) DOM更新后的响应（MutationObserver)<br> (3) 在渲染前完成必要操作<br> (4) 保证操作顺序的原子性</p><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题"><span>常见问题</span></a></h2><p><strong>1. 为什么微任务优先级更高？</strong><br> 微任务为JavaScript引擎内部任务，需要在渲染更新前完成所有状态变更。<br><strong>2. 多个微任务会阻塞页面渲染吗？</strong><br> 长时间运行的微任务会阻塞渲染，应避免在微任务中进行大量计算。<br><strong>3. 如何手动创建宏任务/微任务？</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 宏任务</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 微任务</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {});</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queueMicrotask</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4.Node.js环境有何不同？</strong><br> Node.js中，process.nextTick优先级最高，其次是微任务，然后是宏任务。</p><h2 id="最佳实践建议" tabindex="-1"><a class="header-anchor" href="#最佳实践建议"><span>最佳实践建议</span></a></h2><p><strong>1.将耗时操作放入宏任务</strong> 以避免阻塞渲染<br><strong>2.关键状态更新使用微任务</strong> 确保一致性<br><strong>3.避免在微任务中处理过多任务</strong> 防止阻塞<br><strong>4.使用queueMicrotask替代多层Promise</strong> 提高代码可读性<br><strong>5.复杂操作使用宏任务分时执行</strong> 保持页面流畅性<br> 理解宏任务和微任务的机制对于编写高效、无阻塞的JavaScript代码至关重要，尤其是在处理复杂异步逻辑时，合理的任务分配可以显著提升应用性能。</p><h2 id="为什么事件循环机制微任务只有一个-宏任务可以多个" tabindex="-1"><a class="header-anchor" href="#为什么事件循环机制微任务只有一个-宏任务可以多个"><span>为什么事件循环机制微任务只有一个，宏任务可以多个？</span></a></h2><p>我们讨论的是JavaScript中的事件循环（Event Loop）机制。事件循环负责处理异步任务，并将它们分为宏任务（macrotasks）和微任务（microtasks）。为了理解为什么微任务队列只有一个而宏任务队列可以有多个，我们需要回顾一下事件循环的基本原理。</p><p><strong>事件循环的工作流程如下：</strong></p><ul><li>执行一个宏任务（例如：script整体代码、setTimeout、setInterval、setImmediate、I/O操作、UI渲染等）。</li><li>执行过程中如果遇到微任务（如Promise的then/catch/finally、process.nextTick、MutationObserver等），则将它们添加到微任务队列中。</li><li>当前宏任务执行完毕后，立即依次执行微任务队列中的所有微任务（直到微任务队列清空）。</li><li>进行必要的UI渲染（如果有的话）。</li><li>然后从宏任务队列中取出下一个宏任务执行，如此循环。</li></ul><p><strong>关键点：</strong></p><ol><li><p>每个事件循环（Event Loop）只有一个微任务队列（microtask queue）。在一个宏任务执行完毕后，会清空整个微任务队列。这是因为微任务是在当前执行栈结束后立刻执行的任务，它们应该被尽快地、连续地执行，而不应该被打断（除非又产生了新的微任务，但也会在当前循环中被清空）。</p></li><li><p>而宏任务队列（macrotask queue）则可以有多个。这是因为宏任务来源不同，不同的宏任务会被分配到不同的宏任务队列中。例如：</p></li></ol><ul><li>setTimeout的回调会被放入“定时器”宏任务队列。</li><li>DOM事件回调会被放入“交互”宏任务队列。</li><li>网络请求（fetch）的回调会被放入“网络”宏任务队列。</li><li>等等。<br> 事件循环会按照一定的顺序（由规范定义）从不同的宏任务队列中选择一个队列，然后从该队列中取出最老的宏任务执行。常见的宏任务队列包括：定时器队列、I/O事件队列、检查队列（setImmediate）、关闭事件的回调队列等。</li></ul><p><strong>为什么这样设计？</strong></p><ol><li><p>微任务的设计目的是在宏任务执行完成后，渲染之前，执行一些高优先级的任务。因此，它们需要立即执行，不能被延迟。所以设计为一个队列，并且在该阶段一次性全部执行完毕。</p></li><li><p>宏任务的设计则允许我们将不同来源的任务分类，以便事件循环可以按优先级顺序处理它们（例如，用户交互的任务可能比定时器任务更重要，所以可能会被优先处理）。这样也使得事件循环能够更有效地管理不同来源的异步任务。</p></li></ol><p><strong>总结：</strong></p><ul><li><p>微任务队列只有一个，因为微任务需要在当前宏任务结束后立即执行，并且在执行微任务时如果产生了新的微任务，会继续在同一个队列中执行直到清空，这是为了确保微任务的高优先级和连续性。</p></li><li><p>宏任务队列有多个，因为事件循环需要管理来自不同任务源的宏任务，并按照规定的顺序（如先处理交互事件再处理定时器）来执行。</p></li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>注意：虽然我们常说有多个宏任务队列，但具体到事件循环中，它实际上是按照一定的顺序从多个宏任务队列中挑选任务。例如，在浏览器环境中，事件循环可能会优先处理用户输入事件，然后再处理网络事件，再然后是定时器事件等。</p></div><p>在事件循环（Event Loop）机制中，<strong>微任务队列（Microtask Queue）只有一个，而宏任务队列（Macrotask Queue）可能有多个。</strong> 这是由设计目标和优先级差异决定的：</p><h3 id="_1-微任务的设计目标-高优先级与连续性" tabindex="-1"><a class="header-anchor" href="#_1-微任务的设计目标-高优先级与连续性"><span>1. 微任务的设计目标：高优先级与连续性</span></a></h3><p><strong>1.单队列实现即时执行：</strong><br> 微任务（如 Promise.then、MutationObserver、queueMicrotask）必须在当前宏任务结束之后、下一个宏任务开始之前立即执行，且不能中断。如果存在多个微任务队列，可能无法保证这种连续的执行顺序，导致优先级混乱。<br><strong>2.避免渲染阻塞：</strong><br> 浏览器在重新渲染前必须清空微任务队列。单队列确保了所有微任务都在渲染前完成，避免渲染延迟（如更新 DOM 后需立刻执行回调）。</p><h3 id="_2-宏任务的设计目标-任务来源多样化" tabindex="-1"><a class="header-anchor" href="#_2-宏任务的设计目标-任务来源多样化"><span>2. 宏任务的设计目标：任务来源多样化</span></a></h3><p><strong>1.多队列管理不同来源：</strong><br> 宏任务（如 setTimeout、DOM 事件、I/O 回调）来源多样（定时器、用户交互、网络请求等）。不同来源的宏任务需要分队列管理，以控制执行顺序（例如优先处理用户点击而非定时器）。<br><strong>2.与浏览器调度机制匹配：</strong><br> 浏览器通过多个宏任务队列实现调度优化（如 requestAnimationFrame 在渲染前执行，用户输入事件优先于脚本执行）。</p><h3 id="_3-执行流程的差异" tabindex="-1"><a class="header-anchor" href="#_3-执行流程的差异"><span>3. 执行流程的差异</span></a></h3><p><strong>1.微任务队列：</strong><br> 当 JS 调用栈清空时，事件循环会一次性清空整个微任务队列（包括执行中新产生的微任务）。单队列可避免执行一半被其他宏任务插入。<br><strong>2.宏任务队列：</strong><br> 事件循环按优先级规则（如浏览器定义的顺序）从多个宏任务队列中取出一个任务执行，执行后可能再次检查微任务队列。</p><h3 id="_4-简单记忆" tabindex="-1"><a class="header-anchor" href="#_4-简单记忆"><span>4. 简单记忆</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>┌───────────────────┐</span></span>\n<span class="line"><span>│   宏任务（如点击事件）  │ → 执行 → 清空微任务队列 → 渲染（可选）</span></span>\n<span class="line"><span>└───────────────────┘</span></span>\n<span class="line"><span>↑          ↓</span></span>\n<span class="line"><span>│     ┌───────────┐</span></span>\n<span class="line"><span>│     │ 微任务队列   │ ← 微任务优先级最高</span></span>\n<span class="line"><span>│     └───────────┘</span></span>\n<span class="line"><span>└─ 多个宏任务队列等待调度</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>1.微任务单队列：</strong> 确保高优先级任务的连续执行，不被打断。<br><strong>2.宏任务多队列：</strong> 适应不同任务源的调度需求（如用户交互、网络响应）。<br> 这种设计平衡了效率（微任务快速响应）与灵活性（宏任务按来源分组），避免低优先级宏任务阻塞关键微任务。</p>',102))])}]]),t=JSON.parse('{"path":"/code/JavaScript-TypeScript/microtasks-macrotasks.html","title":"微任务与宏任务","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","sticky":66,"category":["前端开发"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"微任务与宏任务\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T08:45:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"reveal\\",\\"url\\":\\"https://shenlirong.github.io/test/\\"}]}"],["meta",{"property":"og:url","content":"https://shenlirong.github.io/test/blog/code/JavaScript-TypeScript/microtasks-macrotasks.html"}],["meta",{"property":"og:site_name","content":"reveal"}],["meta",{"property":"og:title","content":"微任务与宏任务"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T08:45:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T08:45:40.000Z"}]]},"git":{"createdTime":1754673192000,"updatedTime":1755161140000,"contributors":[{"name":"shenlirong","username":"shenlirong","email":"shenlirong@inspur.com","commits":3,"url":"https://github.com/shenlirong"}]},"readingTime":{"minutes":16.15,"words":4846},"filePathRelative":"code/JavaScript-TypeScript/microtasks-macrotasks.md","excerpt":""}')}}]);