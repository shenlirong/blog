---
title: 字符串
icon: pen-to-square
# sticky: -1
category:
  - 知识点篇
# permalink: /website/
---

<!-- more -->
::: info
此处存放的一些常用字符串方法。
:::

### 核心概念：字符串是不可变的（Immutable）
在大多数语言中，字符串是“不可变”的。这意味着所有字符串方法都不会改变原字符串，而是返回一个新的字符串。
例如：
```python
s = "Hello"
new_s = s.upper() # 返回 "HELLO"
print(s) # 原字符串不变，输出 "Hello"
print(new_s) # 输出 "HELLO"
```
---
```javascript
常用的JavaScript字符串方法包括：
  - charAt(index): 返回指定位置的字符
  - charCodeAt(index): 返回指定位置字符的Unicode编码
  - concat(str1, str2, ...): 连接两个或多个字符串
  - indexOf(searchValue, fromIndex): 返回指定字符串第一次出现的索引
  - lastIndexOf(searchValue, fromIndex): 返回指定字符串最后一次出现的索引
  - match(regexp): 检索匹配项
  - replace(searchValue, replaceValue): 替换匹配的字符串
  - search(regexp): 搜索匹配项
  - slice(startIndex, endIndex): 提取字符串片段
  - split(separator, limit): 将字符串分割为数组
  - substring(startIndex, endIndex): 提取字符串中介于两个索引之间的字符
  - toLowerCase(): 转换为小写
  - toUpperCase(): 转换为大写
  - trim(): 去除两端空白
  - trimStart(): 去除开头空白
  - trimEnd(): 去除结尾空白
  - startsWith(searchString, position): 检查是否以指定字符串开头
  - endsWith(searchString, length): 检查是否以指定字符串结尾
  - includes(searchString, position): 检查是否包含指定字符串
  - repeat(count): 重复字符串
  - padStart(targetLength, padString): 在开头填充
  - padEnd(targetLength, padString): 在结尾填充

    全面的字符串方法分类​：
  - 基础方法（charAt, charCodeAt, concat）
  - 搜索方法（indexOf, lastIndexOf, includes）
  - 提取方法（slice, substring, substr）
  - 修改方法（replace, split）
  - 大小写转换（toLowerCase, toUpperCase）
  - 空白处理（trim, trimStart, trimEnd）
  - 其他方法（startsWith, endsWith, repeat）
```
### 一、Python 字符串方法
#### 1. 大小写转换
- .upper(): 转换为大写
- .lower(): 转换为小写
- .capitalize(): 首字母大写
- .title(): 每个单词首字母大写
- .swapcase(): 大小写互换
#### 2. 查找和替换
- .find(sub) / .index(sub): 查找子串，返回索引（找不到时，find 返回 -1，index 抛出异常）
- .rfind(sub) / .rindex(sub): 从右边开始查找
- .replace(old, new[, count]): 替换子串（count 可指定替换次数）
- .count(sub): 统计某个子串出现的次数
#### 3. 字符串判断（返回 True 或 False）
- .startswith(prefix): 是否以某子串开头
- .endswith(suffix): 是否以某子串结尾
- .isalpha(): 是否所有字符都是字母
- .isdigit(): 是否所有字符都是数字
- .isalnum(): 是否所有字符都是字母或数字
- .isspace(): 是否所有字符都是空白符（空格、换行、制表符等）
- .islower(): 是否所有字符都是小写
- .isupper(): 是否所有字符都是大写
#### 4. 分割和连接
- .split(sep=None): 根据分隔符（默认为所有空白符）分割字符串，返回列表
- .splitlines(): 按行分割
- .join(iterable): 用原字符串作为连接符，将可迭代对象（如列表）中的元素连接成一个新字符串
```python
lst = ["Python", "is", "great"]
s = " ".join(lst) # 输出 "Python is great"
```
#### 5. 去除空白和填充
- .strip([chars]): 去除左右两侧的指定字符（默认为空白符）
- .lstrip([chars]): 去除左侧的指定字符
- .rstrip([chars]): 去除右侧的指定字符
- .zfill(width): 用 0 在左边填充字符串，使其达到指定长度
- .center(width[, fillchar]): 将字符串居中，并用指定字符（默认为空格）填充至长度 width
#### 6. 格式化
- .format(): 格式化字符串的现代方式（推荐）
```python
"Hello, {}!".format("World") # 输出 "Hello, World!"
```
- f-string (Python 3.6+): 更简洁的格式化方法
```python
name = "World"
s = f"Hello, {name}!" # 输出 "Hello, World!"
```
---

### 二、JavaScript 字符串方法
JavaScript 的方法与 Python 非常相似，但语法上是小驼峰命名（camelCase）。
#### 1. 大小写转换
- .toUpperCase(): 转换为大写
- .toLowerCase(): 转换为小写
#### 2. 查找和替换
- .indexOf(searchValue) / .lastIndexOf(): 查找子串，返回索引（找不到返回 -1）
- .includes(searchValue): 判断是否包含子串（返回 true/false）
- .startsWith(searchValue) / .endsWith(): 判断开头/结尾
- .replace(searchValue, newValue): 替换第一个匹配的子串
- .replaceAll(searchValue, newValue): (ES2021) 替换所有匹配的子串
#### 3. 分割和连接
- .split(separator): 分割字符串，返回数组
- .concat(str2, ...): 连接字符串（通常更常用 + 或模板字符串）
- .repeat(count): 将字符串重复 count 次并返回
#### 4. 截取和获取
- .slice(start, end): 提取子串（支持负数索引）
- .substring(start, end): 提取子串（类似 slice，但不支持负数）
- .substr(start, length):（已废弃）不推荐使用
- .charAt(index): 获取指定位置的字符
- .charCodeAt(index): 获取指定位置字符的 Unicode 编码
#### 5. 去除空白
- .trim(): 去除左右两侧空白
- .trimStart() / .trimEnd(): 去除左侧或右侧空白
#### 6. 格式化
- 模板字符串（Template literals） (ES6): 使用反引号 ` 和 ${} 插入变量
```javascript
const name = "World";
const s = `Hello, ${name}!`; // 输出 "Hello, World!"
```
---

### 总结与建议
|功能|Python 方法|JavaScript 方法|
|--|--|--|
|转大写|upper()|toUpperCase()|
|查找索引|find() / index()|indexOf()|
|替换|replace()|replace() / replaceAll()|
|分割|split()|split()|
|连接数组|join()|concat() 或 +|
|去除空白|strip()|trim()|
|判断开头|startswith()|startsWith()|
|格式化|f"{}" / format()|` ${} `|

最佳实践：
1. 查阅官方文档：这是最权威、最全面的方法。遇到不确定的用法，随时搜索 “MDN String” (JavaScript) 或 “Python string methods”。
1. 注意语言差异：虽然功能相似，但方法名和参数细节（如 slice 和 substring 的区别）需要特别注意。
1. 多练习：字符串处理是编程基本功，多写代码是掌握它们的最好方式。

<test></test>

### 字符串操作方法
#### 1.字符串最后一个单词的长度
```javascript
const fun=(arr)=>{
    const arr=arr.split(' ')
    return arr[arr.length -1].length
}
console.log(fun('helloWolrd'))//10
console.log(fun('A b C 123 D')) // 1
// 或者
const fun=(arr)=>{
    const arr=arr.split(' ')
    return arr.pop().length //返回删除元素的长度
}
```
#### 2.计算某字符出现次数
```javascript
const dn=(str,substr)=>{
//转换为小写保持格式一直，避免判断的时候由于输入出现问题
 const arr=str.toLowerCase().split(substr.toLowerCase()).length -1
}
console.log(dn('hwe333','3'))//3
```

#### 3.字符串分隔
```javascript
//8个字符为一行，不足8个字符用0补足
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void async function () {
    while (line = await readline()) {
        var str = line + '00000000';
        for (let i = 8; i < str.length; i += 8) {
            console.log(str.substring(i - 8, i));
        }
    }
    //或者
     while (line = await readline()) {
        const overNumber = line.length % 8
        const result = line.concat(new String("0").repeat(overNumber ? 8 - overNumber : 0))
        for (let i = 0; i < result.length;) {
            console.log(result.substring(i, i += 8))
        }
    }
}()
//输入'helloworld',输出：hellowor，ld000000
```

#### 4.进制转换
```javascript
//将16进制转换为10进制
//说明：回忆十六进制转化为十进制的方法：从右往左，将第 i 位乘以 16的i次方，然后求和。
parseInt()是 ​JavaScript​ 中的一个全局函数，它的主要作用是将一个字符串解析成一个整数。如果无法解析，则返回 NaN。
parseInt(input, 16)
```

#### 5.字符个数统计
```javascript
//对于字符串个数统计的问题，先将字符串转换为数组，再将数组去重，剩下的就是不同字符串个数
while(line = await readline()){
    const arr=line.split('')
    const num=(Array.from(new Set(arr))).length
    console.log(num)
}
//输入：[@A8aA].0，输出：8
```

#### 6.字符数字颠倒
```javascript
//对于字符串个数统计的问题，先将字符串转换为数组，再将数组去重，剩下的就是不同字符串个数
while(line = await readline()){
    var str=''
       for(let i=0;i<line.length;i++){
        str+=line[line.length-1-i]
       }
       console.log(str)
    //或者
    const sub=[...line].reverse().join('')//利用结构赋值，把字符串里面每个对象转换为数组
}
//输入：1516000，输出：0006151
```

#### 7.字符串中找出连续最长的数字串
```javascript
//对于字符串个数统计的问题，先将字符串转换为数组，再将数组去重，剩下的就是不同字符串个数
while(line = await readline()){
    let dt = "";
        line.split('').forEach(item => {
            if (/^[0-9]*$/.test(item) && item !== '') {
                dt += item;
            } else {
                dt += ',';
            }
        })

        let num = 0;
        let out = '';
        dt.split(',').forEach((item, index) => {
            if (item.length > num) {
                num = item.length
                out = item;
            }
        });
        console.log(out);
}
//输入：abcd12345678910ed125ss123456789，输出：12345678910
```

#### 8.字符串排序
```javascript
//按照字母顺序a->b，从小到大
while(line = await readline()){
    let arr = []
    while ((line = await readline())) {
        arr.push(line)
    }
    arr.sort()
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i])
    }
}
//输入：zbcpa，输出：abcpz
```

#### 9.查找无重复最长子串
```javascript
while(line = await readline()){
    let start = 0,
    maxLength = 0,
    maxStart = 0;
    let charMap = new Map();
    for (let end = 0; end < line.length; end++) {
        let char = line[end];
        if (charMap.has(char) && charMap.get(char) >= start) {
            start = charMap.get(char) + 1;
        }
        charMap.set(char, end);
        if (end - start + 1 > maxLength) {
            maxLength = end - start + 1;
            maxStart = start;
        }
    }
    console.log(maxLength)
   return {
     substring:line.substring(maxStart ，maxStart + maxLength),//返回对应的字符串
     length:maxLength//返回的字符串对于的最大长度
   }
}
//输入：zbcpa，输出：5,输入：pwwkew，输出：3
```

#### 10.坐标移动
```javascript
while(line = await readline()){
//不使用正则的解法，只使用于长度小于等于3的字符类型
let x = 0
let y = 0
let strs=line.split(';')
for (let i = 0; i < strs.length; i++) {
    let str = strs[i]
    let num = Number(str.slice(1))
    if (str.length <= 3 && str.length > 1 && !isNaN(num)) {
        if (str[0] === 'A') {
            x -= num
        } else if (str[0] === 'D') {
            x += num
        } else if (str[0] === 'W') {
            y += num
        } else if (str[0] === 'S') {
            y -= num
        }
    }
}
console.log([x,y].join(','))

//使用正则的解法
var arr = [];
    var newLineArr = line.split(";");
    var reg = /^(A|D|W|S){1}[0-9]{1,2}$/;
    // print(reg.test("A11"));
    for (var i = 0; i < newLineArr.length; i++) {
        if (reg.test(newLineArr[i])) {
            arr.push(newLineArr[i]);
            //         print(newLineArr[i]);
        }
    }
    var x = 0;
    var y = 0;
    for (var j = 0; j < arr.length; j++) {
        var dir = arr[j].charAt(0);
        var step = Number(arr[j].slice(1));
        //     print(dir,step);
        switch (dir) {
            case "A":
                x = x - step;
                break;
            case "D":
                x = x + step;
                break;
            case "W":
                y = y + step;
                break;
            case "S":
                y = y - step;
                break;
            default:
                x = x + 0;
                break;
        }
    }
    var reslut = [x, y];
    var strR = reslut.join(",");
    console.log(strR)
}
//输入：zbcpa，输出：abcpz
```

#### 11.删除字符串中出现次数最少的字符
```javascript
while(line = await readline()){
    let obj = {};
    let res = "";
    let str=line
    for (let i = 0; i < str.length; i++) {
        if (obj[str[i]]) obj[str[i]]++;
        else obj[str[i]] = 1;
    }
    let min = Math.min(...Object.values(obj));
    for (let i = 0; i < str.length; i++) {
        if (obj[str[i]] !== min) res += str[i];
        else res=''
    }
    console.log(res);
}
//输入：aabcddd，输出：aaddd
```

#### 12.密码验证合格程序
```javascript
while(line = await readline()){
   const list = [].push(line)

for(let itm of list){
    if(!(/.{9,}/.test(itm))){//任意字符且长度大于等于9
        console.log('NG');
        continue;
    }
    let sum = 0;
    if(/[a-z]/.test(itm))sum++
    if(/[A-Z]/.test(itm))sum++
    if(/[\d]/.test(itm))sum++
    if(/[^\da-zA-Z]/.test(itm))sum++ //匹配任何不是数字也不是字母的字符，匹配特殊字符
    
    if(sum<3){
        console.log('NG');
        continue;
    }
    if(/(.{3,}).*\1/g.test(itm)){//匹配任何重复出现的至少 3 个字符的子串，且两次出现之间可以有任意字符
        console.log('NG');
    }else {
        console.log('OK');
    }
    
}

}

```

#### 13.简单密码
```javascript
while(line = await readline()){
    let strArr = [...line];
        let res = [];
        for (let v of strArr) {
            //如果是大写字母
            if (/[A-Z]/.test(v)) {
                if (v.toLowerCase() === "z") {
                    v = "a";
                } else {
                    v = v.toLowerCase().charCodeAt(0) + 1;//往后挪一个，charCodeAt()将字符转换为 Unicode 编码（整数）
                    v = String.fromCharCode(v);//将加 1 后的 Unicode 编码转换回对应的字符
                }

                res.push(v);
            } else if (/[a-z]/.test(v)) {
                //如果是小写字母
                if ("abc".split("").includes(v)) {
                    v = 2;
                } else if ("def".split("").includes(v)) {
                    v = 3;
                } else if ("ghi".split("").includes(v)) {
                    v = 4;
                } else if ("jkl".split("").includes(v)) {
                    v = 5;
                } else if ("mno".split("").includes(v)) {
                    v = 6;
                } else if ("pqrs".split("").includes(v)) {
                    v = 7;
                } else if ("tuv".split("").includes(v)) {
                    v = 8;
                } else if ("wxyz".split("").includes(v)) {
                    v = 9;
                }
                res.push(v);
            } else {
                res.push(v);
            }
        }
        console.log(res.join(''))
}

```

#### 14.字符串排序
```javascript
while(line = await readline()){
    let arr = line.split("");
    let sorted = [];
    for (let i = 0; i < 26; i++) {//这段代码将字母排序
        for (let j = 0; j < arr.length; j++) {
            if (
                arr[j].charCodeAt(0) == 65 + i ||
                arr[j].charCodeAt(0) == 97 + i
            ) {
                sorted.push(arr[j]);
            }
        }
    }
    for (let i = 0; i < arr.length; i++) {
        if (!/[A-Za-z]/g.test(arr[i])) {//表示除了字母以外的字符正常显示
            sorted.splice(i, 0, arr[i]);
        }
    }
    console.log(sorted.join(""));
}
// 输入：BabA，输出：aABb
```

#### 15.查找兄弟单词
```javascript
while(line = await readline()){
     let argArr=line.split(' ')
        let j = 0;
        let num = argArr[j++] - 0;
        let arrs = [];
        let findArr = [];
        let sum = 0;
        for (let i = 0; i < num; i++) {
            let line = argArr[j++];
            arrs.push(line);
        }
        let target = argArr[j++];
        let k = argArr[j++];
        for (let i = 0; i < num; i++) {
            if (
                arrs[i] !== target &&
                arrs[i].split("").sort().join("") ===
                    target.split("").sort().join("")
            ) {
                sum++;
                findArr.push(arrs[i]);
            }
        }
        findArr = findArr.sort();
        console.log(sum);
        if (findArr[k - 1]) {
            console.log(findArr[k - 1]);
        }
}
```

#### 16.字符串加解密
```javascript
let i=0;
while(line = await readline()){
    i++;
    let type = i % 2 == 0;
    let arr = line.split("");
    let newArr = [];
    arr.forEach((str) => {
        if (/[a-z]/.test(str)) {
            if (type) {
                if (str == "a") {
                    newArr.push("Z");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toUpperCase().charCodeAt(0) - 1
                        )
                    );
                }
            } else {
                if (str == "z") {
                    newArr.push("A");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toUpperCase().charCodeAt(0) + 1
                        )
                    );
                }
            }
        } else if (/[A-Z]/.test(str)) {
            if (type) {
                if (str == "A") {
                    newArr.push("z");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toLowerCase().charCodeAt(0) - 1
                        )
                    );
                }
            } else {
                if (str == "Z") {
                    newArr.push("a");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toLowerCase().charCodeAt(0) + 1
                        )
                    );
                }
            }
        } else if (/[0-9]/.test(str)) {
            if (type) {
                if (str == "0") {
                    newArr.push("9");
                } else {
                    newArr.push(+str - 1);
                }
            } else {
                if (str == "9") {
                    newArr.push("0");
                } else {
                    newArr.push(+str + 1);
                }
            }
        } else {
            newArr.push(str);
        }
    });
    console.log(newArr.join(""));
}

```

#### 17.单词倒序
```javascript
 while (line = await readline()) {
        //通过正则表达式分隔
        var arr = line.split(/[^A-Za-z]+/).reverse().join(' ')
        console.log(arr);
        //或者替换
        let str = line
        let str2 = str.replace(/[^a-zA-Z]+/g, ' ');
        let arr = str2.split(' ').reverse();
        console.log(arr.join(' '));
    }
//输入：Nowcoder Hello ，输出：Hello Nowcoder
//输入：$bo*y gi!r#l ，输出：l r gi y bo
```

#### 18.密码截取
```javascript
 while (line = await readline()) {
    let res = [];
    for (let i = 0; i < line.length; i++) {
        let temp = [];
        if (line[i] === line[i + 1]) {
            temp = [line[i], line[i + 1]];
            temp = getPsd(temp, i - 1, i + 2);
            res = temp.length > res.length ? temp : res;
        }
        temp = [line[i]];
        temp = getPsd(temp, i - 1, i + 1);
        res = temp.length > res.length ? temp : res;
    }
    console.log(res.length);

    function getPsd(arr, i, j) {
        while (i > -1 && j < line.length) {
            if (line[i] === line[j]) {
                arr.unshift(line[i]);
                arr.push(line[j]);
                i--;
                j++;
            } else {
                return arr;
            }
        }
        return arr;
    }
 }
//输入：12HHHHA ，输出：4
//输入：ABBA ，输出：4
```

#### 19.整数与IP地址间的转换
```javascript
var result
while (line = await readline()) {
    if (line.includes(".")) {//将ip地址转化为整数
        result=  toNum(line)
    } else {//将数字转化为ip地址
        result= toIp(line)
    }
    console.log(result)
}
function toIp(num) {
    const str = Number(num).toString(2).padStart(32, "0")
    const arr = [str.slice(0, 8), str.slice(8, 16), str.slice(16, 24), str.slice(24, 32)]
    const ip = arr.map(ele => parseInt(ele, 2)).join(".")
    return (ip)
}

function toNum(ip) {
    const arr = ip.split(".").map(ele => Number(ele).toString(2)).map(ele => ele.padStart(8, "0"))
    const num = arr.join("")
    return (parseInt(num, 2))
}

```

#### 20.密码截取
```javascript
 while (line = await readline()) {
        //通过正则表达式分隔
        var arr = line.split(/[^A-Za-z]+/).reverse().join(' ')
        console.log(arr);
        //或者替换
        let str = line
        let str2 = str.replace(/[^a-zA-Z]+/g, ' ');
        let arr = str2.split(' ').reverse();
        console.log(arr.join(' '));
    }
//输入：Nowcoder Hello ，输出：Hello Nowcoder
//输入：$bo*y gi!r#l ，输出：l r gi y bo
```

#### 21.字符串加密（待）
```javascript
 while (line = await readline()) {
    var key = readline();
    var msg = readline();
    var line = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ').toLocaleLowerCase();
    var set = new Set(key + line);
    var list = new Array(...set);
    var final = '';
    for (var i = 0; i < msg.length; i++) {
        var index = line.indexOf(msg[i]);
        var mi = list[index];
        final += mi[0];
    }
    console.log(final);
}

```

#### 22.统计字符
```javascript
 while (line = await readline()) {
    //对于给定的由可见字符和空格组成的字符串，统计其中英文字母、空格、数字和其它字符的个数。
    let str = line;
    let a = str.replace(/[^a-zA-Z]+/g, "");
    let b = str.replace(/[^\s]+/g, "");
    let c = str.replace(/[^0-9]+/g, "");
    let d = str.replace(/[a-zA-Z0-9\s]+/g, "");
    console.log(a.length);
    console.log(b.length);
    console.log(c.length);
    console.log(d.length);
    }

```
#### 23. 称砝码（待）
```javascript
 while (line = await readline()) {
    //对于给定的n种砝码，现在要用这些砝码去称物体的重量（放在同一侧），问能称出多少种不同的重量，
    let line1 = readline();let line2 = readline();let line3 = readline();
    let m = line2.split(' '); //每种砝码的重量
    let x = line3.split(' '); //每种砝码对应的数量范围
    let fama = []            //序列化砝码，比如两个1g和一个2g的砝码用[1,1,2]表示
    for (let i = 0; i < m.length; i++) {
      for (let j = 0; j < x[i]; j++) {
        fama.push(Number(m[i]))
       }
    }
    let kind = new Set();    //用set表示加入当前砝码之前能产生的重量种类
    kind.add(0);            //set初始化为0
    // 当第一个1g砝码放入时，set中要插入原先所有元素+1g后的结构，即{0,0+1}，插入后变为{0,1}
    // 当第二个1g砝码放入时，set要插入{0+1,1+1},变为{0,1,2}
    // 第三个2g砝码放入时，set要插入{0+2,1+2,2+2},变为{0,1,2,3,4}
    for (let i = 0; i < fama.length; i++) {
        let arr = [...kind]    //用一个数组来缓存当前种类的砝码的值
        for (let k of arr) {
            kind.add(k + fama[i]);
        }
    }
        console.log(kind.size)
    }

```

#### 24.  四则运算
```javascript
//使用eval()函数
 while (line = await readline()) {
    let  a = line.replace('{','(').replace('}',')')
    console.log(eval(a))
    }
//输入：3+2*{1+2*[-4/(8-6)+7]}，输出:25
```

#### 25.  计算字符串的编辑距离（待）
```javascript
var minDistance = function(word1, word2) {
    let n = word1.length;
    let m = word2.length;
    if(n*m === 0) return n+m;
    if(word1 === word2) return 0;
    let dp = [];
    for(let i = 0;i <= n;i++){
        dp.push([])
        for(let j = 0;j <= m;j++){
            if(i*j){
                dp[i][j] = word1[i-1] == word2[j-1]? dp[i-1][j-1]: (Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1);
            }else{
                dp[i][j] = i + j;
            }
        }
    }
    return dp[n][m];
};



while(str1 = readline()) {
  const str2 = readline();
  console.log(minDistance(str1, str2));
}

```

#### 26.  高精度整数加法（待）
```javascript
const b = readline().split('');
const a = readline().split('');
let c = 0
let res='';
while( a.length || b.length || c) {
  c += ~~a.pop() + ~~b.pop()
  res = c%10 + res;
  c = c>9 ? 1 : 0;
}
console.log(res)
```

#### 27.  找出第一个只出现一次的字符。如果不存在，则输出-1
```javascript
    while ((line = await readline())) {
        console.log(outputFirstLetter(line))
    }
    function outputFirstLetter(str) {
        const len = str.length;
        for (let i = 0; i < len; i++) {
            if (str.indexOf(str[i]) === str.lastIndexOf(str[i])) {
                return str[i];
            }
        }
        return -1;
    }
```

#### 28.  DNA序列
```javascript
    while ((line = await readline())) {
       let str = line;
        let num = line;
        let result = "";
        let max = 0;
        for (let i = 0; i <= str.length - num; i++) {
            let s = str
                .substr(i, num)
                .split("")
                .filter((item) => item == "C" || item == "G").length;
            if (s > max) {
                result = str.substr(i, num);
                max = s;
            }
        }
        console.log(result);
    }
   
```

#### 29.  参数解析
```javascript
    while ((line = await readline())) {
      let str=line;
        let arr;
        arr = [];
        let flag = false;
        let word = "";
        for (let i = 0; i < str.length; i++) {
            if (str[i] === '"') {
                flag = !flag;
            } else if (str[i] == " " && !flag) {
                arr.push(word);
                word = "";
            } else {
                word += str[i];
            }
        }
        arr.push(word);

        console.log(arr.length);
        arr.forEach((el) => {
            console.log(el);
        });
    }
   
```

#### 30.  合法IP
```javascript
    while ((line = await readline())) {
    testIp(line)
    }
     function testIp(ipAddr) {
        const temp = ipAddr.split(".");
        if (temp.length !== 4) return "NO";
        for (let t of temp) {
            if (!t.length) return "NO";
            if (t.length > 3) return "NO";
            if (!/^[0-9]*$/.test(t)) return "NO";
            if (parseInt(t) > 255) return "NO";
            if (t !== "" + parseInt(t)) return "NO";
        }
        return "YES";
    }
   
```

#### 30. 在字符串中找出连续最长的数字串
```javascript
    while ((line = await readline())) {
    testIp(line)
    }
      function deal(s) {
        var arr = s.match(/[0-9]+/g);
        var len = [];
        arr.forEach((item) => {
            len.push(item.length);
        });
        var maxLen = Math.max(...len);
        var res = "";
        arr.forEach((item) => {
            if (item.length == maxLen) {
                res += item;
            }
        });
       return res+','+ maxLen;
    }
   
```

#### 31. 蛇形矩阵
```javascript
    while ((line = await readline())) {
        let row = Number(line);
        let arr = [1];
        for (var i = 2; i < row + 1; i++) {
            //确定第一行
            arr.push(arr[arr.length - 1] + i);
        }
        for (var j = 0; j < row; j++) {
            let str = "";
            arr.slice(j).forEach((item) => {
                str = str + (item - j) + " ";
            });
            console.log(str);
        }
    }
      
```

#### 32. 输入n个整数，输出其中最小的k个
```javascript
    let num = await readline()
    while ((line = await readline())) {
        //    console.log(num)
        //    console.log(line)
        let arr = num.concat(line)
        // console.log(arr)
        let a = Array.from(new Set(arr.trim()))
        let b = a.sort()
        let c = a.slice(1).reduce((cur, next) => {
            if (next < cur[0]) {
                return [next, cur[0]]
            } else if (next < cur[1] && pre !== cur[0]) {
                return [cur[0], pre]
            }
            return cur
        }, [Infinity, Infinity])
        console.log(c.join(' '))
        // console.log([b[1], b[2]].join(' '))

    }
      
```

#### 33. MP3光标位置
```javascript
    let num = await readline();
    while ((line = await readline())) {
        let str = line.split("");
        // 声明存储当前列表和选中歌曲的变量
        let menu = [];
        let se = 1;
        // 根据输入的命令分别处理赋值
        if (num <= 4) {
            menu = [1, 2, 3, 4].slice(0, num);
            str.forEach((i) => {
                if (i === "U") {
                    se === 1 ? (se = num) : (se -= 1);
                } else if (i === "D") {
                    se === num ? (se = 1) : (se += 1);
                }
            });
        } else {
            str.forEach((i) => {
                if (i === "U") {
                    if (se === 1) {
                        se = num;
                        menu = [num - 3, num - 2, num - 1, num];
                    } else {
                        se -= 1;
                        se <= menu[0]
                            ? (menu = [se, se + 1, se + 2, se + 3])
                            : (menu = menu);
                    }
                } else if (i === "D") {
                    if (se === num) {
                        se = 1;
                        menu = [1, 2, 3, 4];
                    } else {
                        se += 1;
                        se >= menu[3]
                            ? (menu = [se - 3, se - 2, se - 1, se])
                            : (menu = menu);
                    }
                }
            });
        }
        console.log(menu.join(" "));
        console.log(se);
    }
```

#### 34. 矩阵乘法
```javascript
    const x = await readline();
    const y = await readline();
    const z = await readline();
    const A = [];
    const B = [];
    const C = [];
    for (let i = 0; i < x; i++) {
        A.push((await readline()).split(" ").map(Number));
    }
    for (let i = 0; i < y; i++) {
        B.push((await readline()).split(" ").map(Number));
    }
    for (let i = 0; i < x; i++) {
        const tmpA = [];
        for (let j = 0; j < z; j++) {
            let num = 0;
            for (let k = 0; k < y; k++) {
                num += A[i][k] * B[k][j];
            }
            tmpA.push(num);
        }
        C.push(tmpA);
    }
    C.forEach((item) => {
        console.log(item.join(" "));
    });
      
```

#### 35. 质数因子
```javascript
     while ((line = await readline())) {
        let num =  line;
        let arr = [];
        function getCode(num) {
            let i = 2,
                tep = num;
            while (i <= tep && i * i <= tep) {
                while (num % i == 0) {
                    arr.push(i);
                    num /= i;
                }
                ++i;
            }
            if (num != 1) {
                arr.push(num);
            }

            return arr;
        }

        let res = getCode(num);
        console.log(res.join(" "));
    }
      
```

#### 36. 统计每个月兔子的总数
```javascript
    while ((line = await readline())) {
    let m = line;
    let sum = 1;
    let a = 0;
    let b = 0;
    for (let i = 2; i < m; i++) {
        sum = sum + a;
        a = b;
        b = sum;
    }
    console.log(sum + a + b);
}
      
```

#### 36. 分数线划定
```javascript
    // 1. 解析数据并排序
    const parsedData = list.map((item) => {
        const [id, score] = item.split(" ");
        return {
            id: parseInt(id),
            score: parseInt(score),
            original: item,
        };
    });

    // 2. 按成绩降序、编号升序排序
    parsedData.sort((a, b) => {
        if (b.score !== a.score) {
            return b.score - a.score;
        }
        return a.id - b.id;
    });

    // 3. 获取第k名的成绩作为阈值
    const thresholdIndex = Math.min(Math.max(1, t), parsedData.length);
    const thresholdScore = parsedData[thresholdIndex].score;

    // 4. 筛选出所有成绩大于等于该阈值的学生
    const result = parsedData
        .filter((student) => student.score >= thresholdScore)
        .map((student) => student.original);
      
```
#### 37. 单词出现频率排序
```javascript
   function findFrequentWords(str, minCount = 3) {
        const words = str.split(" ");
        const frequencyMap = new Map();

        // 统计词频
        for (const word of words) {
            frequencyMap.set(word, (frequencyMap.get(word) || 0) + 1);
        }

        // 筛选并排序
        const frequentWords = Array.from(frequencyMap.entries())
            .filter(([word, count]) => count >= minCount)
            .sort((a, b) => {
                // 频次降序
                if (b[1] !== a[1]) {
                    return b[1] - a[1];
                }
                // 字典序升序
                return a[0].localeCompare(b[0]);
            })
            .map((entry) => entry[0]);

        return frequentWords;
    }
      
```

#### 38. 谐距下标对
```javascript
   function countHarmonicPairs(arrStr) {
        const arr = arrStr.split(" ").map(Number);
        const n = arr.length;
        const bMap = new Map();

        for (let i = 0; i < n; i++) {
            // 计算 b_i = a_i - (i+1)，因为下标从1开始
            const b = arr[i] - (i + 1);
            if (bMap.has(b)) {
                bMap.set(b, bMap.get(b) + 1);
            } else {
                bMap.set(b, 1);
            }
        }

        let count = 0;
        for (const freq of bMap.values()) {
            if (freq > 1) {
                count += (freq * (freq - 1)) / 2;
            }
        }

        return count;
    }
      
```

#### 40. 汽水瓶
```javascript
    //某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）
    //允许向老板借空汽水瓶（但是必须要归还） 即 3个空瓶子 = 1瓶汽水 + 1个空瓶子 即 2个空瓶子  = 1瓶汽水 所以：答案就是 n 除以2 ，之后再取整.
    //Math.floor()向下取整
     while (line = await readline()) {
        line = parseInt(line)
     
        // let outVal = (line - (line % 2)) / 2   
        // console.log(outVal)
        if(line !==0)   console.log(Math.floor(line/2))
         
    }
      
```

#### 41. 求小球在第五次落地时所经历的路程和第五次反弹的高度
```javascript
     while (line = await readline()) {
      var initHeight=parseInt(line)
        var sum = initHeight;
        var height = initHeight / 2;
        for (let i = 0; i < 4; i++) {
            sum += height * 2;
            height /= 2;
        }
        console.log(sum)
        console.log(height)
    }
      
```

#### 41. 求小球在第五次落地时所经历的路程和第五次反弹的高度
```javascript
     while (line = await readline()) {
      var initHeight=parseInt(line)
        var sum = initHeight;
        var height = initHeight / 2;
        for (let i = 0; i < 4; i++) {
            sum += height * 2;
            height /= 2;
        }
        console.log(sum)
        console.log(height)
    }
      
```

#### 42. 对于给定的数列，直接求解出省略了多少数字
```javascript
     while (line = await readline()) {
    // 使用正则表达式匹配字符串中的所有数字
    let  numMatches = line.match(/\d+/g);
    // 将匹配的数字字符串转换为数字数组
    const numbers = numMatches.map(Number);
    const start = numbers[0]; // 序列起始数字
    const end = numbers[numbers.length - 1]; // 序列结束数字
    const totalNumbers = end - start + 1; // 计算从起始到结束的总数字个数
    const omittedCount = totalNumbers - numbers.length; // 计算被省略的数字个数
    }
      
```

#### 43. 密码强度等级
```javascript
     while (line = await readline()) {
        solution(line)
    }
    function solution(str) {
        let score = 0;

        // 密码长度
        if (str.lenght <= 4) {
            score += 5;
        } else if (str.length <= 7) {
            score += 10;
        } else {
            score += 25;
        }
        let lowerCaseCharNum = 0; //英文小写字母
        let upperCaseCharNum = 0; //英文大写字母
        let numberNum = 0; //数字个数
        let otherNum = 0; //符号

        // 每种字符可能的长度
        for (let i = 0; i < str.length; i++) {
            let char = str.charAt(i);
            if (/[a-z]/.test(char)) {
                lowerCaseCharNum++;
            } else if (/[A-Z]/.test(char)) {
                upperCaseCharNum++;
            } else if (/[1-9]/.test(char)) {
                numberNum++;
            } else if (isOtherChar(char)) {
                otherNum++;
            }
        }

        // 字母
        if (!lowerCaseCharNum && !upperCaseCharNum) {
            score += 0;
        } else if (lowerCaseCharNum && upperCaseCharNum) {
            score += 20;
        } else {
            score += 10;
        }

        // 数字
        if (numberNum === 1) {
            score += 10;
        } else if (numberNum > 1) {
            score += 20;
        }

        // 符号
        if (otherNum === 1) {
            score += 10;
        } else if (otherNum > 1) {
            score += 25;
        }

        // 奖励
        if (lowerCaseCharNum && upperCaseCharNum && numberNum && otherNum) {
            score += 5;
        } else if (
            (lowerCaseCharNum || upperCaseCharNum) &&
            numberNum &&
            otherNum
        ) {
            score += 3;
        } else if ((lowerCaseCharNum || upperCaseCharNum) && numberNum) {
            score += 2;
        }

        if (score >= 90) {
            return "VERY_SECURE";
        } else if (score >= 80) {
            return "SECURE";
        } else if (score >= 70) {
            return "VERY_STRONG";
        } else if (score >= 60) {
            return "STRONG";
        } else if (score >= 50) {
            return "AVERAGE";
        } else if (score >= 25) {
            return "WEAK";
        }
        return "VERY_WEAK";
    }

    // 判断是否是其他字符
    function isOtherChar(char) {
        let num = parseInt(char.charCodeAt(0));
        if (num >= 0x21 && num <= 0x2f) {
            return true;
        } else if (num >= 0x3a && num <= 0x40) {
            return true;
        } else if (num >= 0x5b && num <= 0x60) {
            return true;
        } else if (num >= 0x7b && num <= 0x7e) {
            return true;
        }
        return false;
    }
      
```

#### 44. 给定区间，判断有K的整数，没有输出-1
```javascript
     while (line = await readline()) {
    let arr = line.split(' ').map(Number)
    let num = arr.pop()
    let start = arr[0];
    let end = arr[arr.length - 1]
    let list = []
    for (let i = start; i < end; i++) {
        list.push(i)
    }
    let isFlag = list.some(item => item % num == 0)
    let result = isFlag ? list.filter(item => item % num == 0) : [-1]
    if (result.length >= 1) console.log(result[0])
    }
    //输入：6 10 3，输出:6或者9中一个，如果没有返回-1
```

#### 45. 输出符合2行2列，总数为3的其中一种矩阵
```javascript
     while (line = await readline()) {
    let arr = (await readline()).split(" ").map(Number);
    let rows = arr[0]; //行数
    let cols = arr[1]; //列数
    let totalSum = arr[2]; //总数
    // console.log(line1)
    if (totalSum < cols) {
        console.log(-1);
    } else {
        // 创建矩阵，所有元素初始化为0
        const matrix = [];
        for (let i = 0; i < rows; i++) {
            matrix.push(Array(cols).fill(0));
        }

        // 确保每行每列至少有一个非零元素
        for (let i = 0; i < Math.min(rows, cols); i++) {
            matrix[i][i] = 1;
        }

        // 处理剩余的行或列
        if (rows > cols) {
            for (let i = cols; i < rows; i++) {
                matrix[i][0] = 1;
            }
        } else if (cols > rows) {
            for (let i = rows; i < cols; i++) {
                matrix[0][i] = 1;
            }
        }

        // 计算当前总和
        let currentSum = 0;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                currentSum += matrix[i][j];
            }
        }

        // 调整总和
        if (currentSum < totalSum) {
            matrix[0][0] += totalSum - currentSum;
        }

        // 格式化输出：每行元素空格分隔，行之间换行
        const output = matrix.map((row) => row.join(" ")).join("\n");
        console.log(output);
    }
}
```

#### 46. 数组由0、1组成，1不相邻，给定一个数n，替换掉n个0，并且不相邻
```javascript
     let a = await readline();
    let arr = (await readline()).split(" ").map(Number);
    let n = parseInt(await readline());
    // 统计当前1的数量
    let currentOnes = arr.filter((x) => x === 1).length;

    // 如果数组全是1，无法再添加
    if (currentOnes === arr.length) return false;

    // 找出所有连续的0序列（空隙）
    let gaps = [];
    let start = -1;

    for (let i = 0; i <= arr.length; i++) {
        if (i < arr.length && arr[i] === 0) {
            if (start === -1) start = i;
        } else {
            if (start !== -1) {
                gaps.push({ start, end: i - 1 });
                start = -1;
            }
        }
    }

    // 计算每个空隙可放置的1的数量
    let maxAdditional = 0;

    for (let gap of gaps) {
        const length = gap.end - gap.start + 1;
        let maxInGap = 0;

        // 检查空隙两侧情况
        const leftBlocked = gap.start > 0 && arr[gap.start - 1] === 1;
        const rightBlocked = gap.end < arr.length - 1 && arr[gap.end + 1] === 1;

        if (leftBlocked && rightBlocked) {
            // 两端都有1 - 最严格的限制
            maxInGap = Math.floor((length - 1) / 2);
        } else if (leftBlocked || rightBlocked) {
            // 一端有1
            maxInGap = Math.floor(length / 2);
        } else {
            // 两端都没有1 - 最宽松的情况
            maxInGap = Math.floor((length + 1) / 2);
        }

        maxAdditional += maxInGap;
    }

    // 检查是否可以达到n个1
    //  maxAdditional >= n? console.log(true):console.log(false)
     console.log( maxAdditional >= n)
```

#### 47. 合并表记录，索引相同，value相加
```javascript
     while ((line = await readline())) {
        let obj = {};
        for (let i = 0; i < parseInt(line); i++) {
            let [k, v] =(await readline()).split(" ");
            // console.log([k,v])
            if (obj[k]) {
                obj[k] += parseInt(v);
            } else {
                obj[k] = parseInt(v);
            }
        }
  
        for (let j in obj) {
            console.log(j + " " + obj[j]);
        }
    }
```

#### 48. 记票统计
```javascript
     let perNum = await readline(); //人数
    let per = (await readline()).split(" "); //具体的人
    let vitNum = await readline(); //总共票数
    let vitPer = (await readline()).split(" "); //投票的内容
    const map = new Map();
    for (let i = 0; i < per.length; i++) {
        map.set(per[i], 0);
    }
    map.set("Invalid", 0);
 
    for (let j = 0; j < vitPer.length; j++) {
        if (map.has(vitPer[j])) {
            map.set(vitPer[j], map.get(vitPer[j]) + 1);
        } else {
            map.set("Invalid", map.get("Invalid") + 1);
        }
    }

    for (const [key, value] of map) {
        console.log(`${key} : ${value}`);
    }
```

#### 49. 实现字通配符*
```javascript 
    let sub = await readline();
    let origin = await readline();
    // console.log(sub,origin)
   
    // 通用方法
    function findPatternMatches(target, pattern) {
        const matches = [];

        // 检查模式中是否包含通配符
        if (!pattern.includes("*")) {
            // 没有通配符 - 直接匹配整个模式
            let pos = target.indexOf(pattern);
            while (pos !== -1) {
                matches.push({
                    start: pos,
                    length: pattern.length,
                    substring: pattern,
                    prefixLength: pattern.length,
                    suffixLength: 0,
                });
                pos = target.indexOf(pattern, pos + 1);
            }
            return matches;
        }

        // 拆分模式为前缀和后缀
        const starIndex = pattern.indexOf("*");
        const prefix = pattern.substring(0, starIndex);
        const suffix = pattern.substring(starIndex + 1);

        // 处理特殊情况：模式为 "*"（匹配所有子串）
        if (prefix === "" && suffix === "") {
            // 匹配所有子串（包括空串）
            for (let start = 0; start <= target.length; start++) {
                for (
                    let length = 0;
                    length <= target.length - start;
                    length++
                ) {
                    matches.push({
                        start,
                        length,
                        substring: target.substring(start, start + length),
                        prefixLength: 0,
                        suffixLength: 0,
                    });
                }
            }
            return matches;
        }

        // 查找所有前缀出现的位置
        const prefixPositions = [];
        let prefixIndex = target.indexOf(prefix);
        while (prefixIndex !== -1) {
            prefixPositions.push(prefixIndex);
            prefixIndex = target.indexOf(prefix, prefixIndex + 1);
        }

        // 查找所有后缀出现的位置
        const suffixPositions = [];
        let suffixIndex = target.indexOf(suffix);
        while (suffixIndex !== -1) {
            // 确保后缀完整匹配
            if (suffixIndex + suffix.length <= target.length) {
                suffixPositions.push(suffixIndex);
            }
            suffixIndex = target.indexOf(suffix, suffixIndex + 1);
        }

        // 处理前缀为空的情况（模式为 "*suffix"）
        if (prefix === "") {
            for (const suffixPos of suffixPositions) {
                for (let start = 0; start <= suffixPos; start++) {
                    const length = suffixPos + suffix.length - start;
                    matches.push({
                        start,
                        length,
                        substring: target.substring(start, start + length),
                        prefixLength: 0,
                        suffixLength: suffix.length,
                    });
                }
            }
            return matches;
        }

        // 处理后缀为空的情况（模式为 "prefix*"）
        if (suffix === "") {
            for (const prefixPos of prefixPositions) {
                for (
                    let length = prefix.length;
                    length <= target.length - prefixPos;
                    length++
                ) {
                    matches.push({
                        start: prefixPos,
                        length,
                        substring: target.substring(
                            prefixPos,
                            prefixPos + length
                        ),
                        prefixLength: prefix.length,
                        suffixLength: 0,
                    });
                }
            }
            return matches;
        }

        // 处理一般情况（模式为 "prefix*suffix"）
        for (const prefixPos of prefixPositions) {
            for (const suffixPos of suffixPositions) {
                // 后缀必须在前缀之后
                if (suffixPos >= prefixPos + prefix.length) {
                    const start = prefixPos;
                    const length = suffixPos + suffix.length - prefixPos;
                    matches.push({
                        start,
                        length,
                        substring: target.substring(
                            prefixPos,
                            suffixPos + suffix.length
                        ),
                        prefixLength: prefix.length,
                        suffixLength: suffix.length,
                    });
                }
            }
        }

        return matches;
    }
    findPatternMatches(origin, sub).map(item => {
        console.log(`${item.start} ${item.length}`)
    })



    //例子(写死)
    function findPatternMatches(str) {
        const matches = [];

        // 遍历字符串中的每个字符
        for (let i = 0; i < str.length; i++) {
            // 如果当前字符是 'o'
            if (str[i] === "o") {
                // 从当前位置向后查找所有 'm'
                for (let j = i + 1; j < str.length; j++) {
                    if (str[j] === "m") {
                        // 计算子串长度
                        const length = j - i + 1;
                        // 记录匹配结果
                        matches.push({
                            start: i,
                            length: length,
                            substring: str.substring(i, j + 1),
                        });
                    }
                }
            }
        }

        // 按起始位置升序排序，相同起始位置按长度升序排序
        matches.sort((a, b) => {
            if (a.start !== b.start) {
                return a.start - b.start;
            }
            return a.length - b.length;
        });

        return matches;
    }

    // 查找匹配
    const matches = findPatternMatches(origin);

    // 输出结果
    if (matches.length === 0) {
        console.log("-1 0");
    } else {
        for (const match of matches) {
            console.log(`${match.start} ${match.length}`);
        }
    }
```

#### 50.  简单错误记录
```javascript
     let obj={}
    while (line = await readline()) {
        let str=line
        const [c, n] = str.split(" ");
        const s = c.substr(c.lastIndexOf('\\') + 1).substr(-16)
        obj[`${s} ${n}`] = (obj[`${s} ${n}`] || 0) + 1
    }

    Object.keys(obj).slice(-8).forEach(el => {
        console.log(`${el} ${obj[el]}`)
    })
```


#### 51.  数据分类处理
```javascript
      while ((line = await readline())) {
        let str=line
        let IArr = str.split(" "); //拆分得到I序列
        let RArr =(await readline()).split(" "); //拆分得到R序列
        IArr.shift(); //删除数组第一位，下同
        RArr.shift();
        RArr = [...new Set(RArr.sort((a, b) => a - b))]; //利用Set去重，同时排序，重新赋值给RArr
        let log = []; //定义输出数组
        RArr.forEach((item) => {
            //对R序列的每一项
            let itemArr = []; //定义临时数组
            for (let i = 0; i < IArr.length; i++) {
                if (IArr[i].includes(item)) {
                    //查找包含R单项的I序列项
                    itemArr.push(i, IArr[i]); //若找到，在临时数组中保存下标和I序列单项
                }
            }
            if (itemArr.length !== 0) {
                //如果临时数组长度大于0
                log.push(item, itemArr.length / 2, ...itemArr); //输出数组中加入R单项，I序列中符合条件的个数，并把保存的临沭数组扩展进来
            }
        });
        log.unshift(log.length); //统计输出数组的长度，并将该数字添加到输出数组的第一位
        console.log(log.join(" "));
    }
```

#### 52.  杨辉三角的变形
```javascript
     let obj={}
    while (line = await readline()) {
       const n = Number(line);
        if (n == 1 || n == 2) {
            console.log("-1");
        } else {
            if (n % 4 == 1 || n % 4 == 3) {
                console.log("2");
            } else if (n % 4 == 2) {
                console.log("4");
            } else if (n % 4 == 0) {
                console.log("3");
            }
        }
    }

```

#### 53.  挑7
```javascript
     let obj={}
    while (line = await readline()) {
       let word=line
        word = parseInt(word, 10);
        let arr = [];
        for (var i = 1; i <= word; i++) {
            ((i + "").includes("7") || !(i % 7)) && arr.push(i);
        }
        console.log(arr.length);
    }
    //输入：20，输出：3  与7有关的3个
```

#### 54. 完全数计算
```javascript
    while (line = await readline()) {
      let num=line
        let count = 0; //计数变量
        //第一个完全数是6，若小于6则输出0
        if (num < 6) {
            console.log(0);
        }
        for (let t = 6; t <= num; t++) {
            let sum = 0;
            //统计因数的和，计数到该数的1/2即可
            for (let i = 1; i <= t / 2; i++) {
                if (t % i == 0) sum += i;
            }
            if (sum == t) count++;
        }
        console.log(count);
    }
    //输入：20，输出：3  与7有关的3个
```

#### 55. 查找组成一个偶数最接近的两个素数
```javascript
    while (line = await readline()) {
      let n=line;
        function isPrime(num) {
            for (let i = 2; i <= Math.sqrt(num); i++) {
                console.log(i)
                if (num % i == 0) return false;
            }
            return true;
        }
     
        let num1, num2;
        for (let i = 1; i <= n / 2; i++) {
            if (isPrime(i) && isPrime(n - i)) {
                num1 = i;
                num2 = n - i;
            }
        }
        console.log(num1);
        console.log(num2);
    }
   
```

#### 56. 尼科彻斯定理
```javascript
    while (line = await readline()) {
       let start = line * (line - 1) + 1;
        let res = [];
        for (let i = 0; i < line; i++) {
            res.push(start + i * 2);
        }
        console.log(res.join("+"));
    }
```

#### 57. 将真分数分解为埃及分数
```javascript
  function gcd(a, b) {
        if (a % b === 0) return b;
        return gcd(b, a % b);
    }

    let str;
    while ((str = await readline())) {
        let [a, b] = str.split("/").map(Number);
        let q = 0;
        const ans = [];
        while (a > 1) {
            q = parseInt(b / a);
            ans.push("1/" + (q + 1));
            a = a * (q + 1) - b;
            b = b * (q + 1);
            let maxGcd = gcd(a, b);
            if (maxGcd > 1) {
                a = a / maxGcd;
                b = b / maxGcd;
            }
        }
        ans.push("1/" + b);
        console.log(ans.join("+"));
    }
```

#### 58. 走方格的方案数
```javascript
   while ((line = await readline())) {
        let [n, m] = line.split(' ').map(e => parseInt(e));
        console.log(solution(n, m));
    }
    function solution(n, m) {
        let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1));
        for (let i = 0; i <= n; i++) {
            dp[i][m] = 1;
        }
        for (let j = 0; j <= m; j++) {
            dp[n][j] = 1;
        }
        for (let i = n; i > 0; i--) {
            for (let j = m; j > 0; j--) {
                dp[i - 1][j - 1] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[0][0];
    }
```

#### 59. 矩阵乘法计算量估算(栈)
```javascript
   while ((line = await readline())) {
        let n=parseInt(line)
        // 1. 创建二维数组 arr 保存输入矩阵
        const arr = [];
        for (let i = 0; i < n; i++) {
            arr[i] =(await readline()).trim().split(" ").map(Number);
        }
        // 2. 获取计算法则 method 字符串
        const method =await readline();
        let result = [],
            count = 0; // result 模拟栈结构，保存待计算的数据
        // 3. 遍历计算法则字符串
        for (let i = 0; i < method.length; i++) {
            if (method[i] === "(") {
                // 3.1 遇到前括号不做处理
            } else if (method[i] === ")") {
                // 3.3 当遇到后括号的时候，出栈计算并将结果重新入栈
                if (result.length >= 2) {
                    const second = result.pop();
                    const first = result.pop();
                    count += first[0] * first[1] * second[1];
                    result.push([first[0], second[1]]);
                }
            } else {
                // 遇到非括号，进行入栈操作
                // 通过字母的 ascii 值判断对应矩阵的顺序
                result.push(arr[method.charCodeAt(i) - 65]);
            }
        }
        console.log(count);
    }
```

#### 60. 火车进站（栈）
```javascript
  function dispatch(trains, inOrder, outOrder) {
    if (outOrder.length === num) {
            res.push(parseInt(outOrder.join("")));
        }
        if (trains.length === num) {
            inOrder.push(trains.shift());
            dispatch(trains, inOrder, outOrder);
            return;
        }
        if (trains.length > 0) {
            let cur = trains.shift();
            inOrder.push(cur);
            dispatch(trains, inOrder, outOrder);
            inOrder.pop();
            trains.unshift(cur);
        }
        if (inOrder.length > 0) {
            let cur = inOrder.pop();
            outOrder.push(cur);
            dispatch(trains, inOrder, outOrder);
            outOrder.pop();
            inOrder.push(cur);
        }
    }

    let num;
    let res = [];
    while ((line = await readline())) {
        num = parseInt(line)
        let trains = (await readline()).split(" ");
        let inOrder = [];
        let outOrder = [];
        dispatch(trains, inOrder, outOrder);
        res.sort((a, b) => a - b);
        res.forEach((el) => {
            console.log(el.toString().split("").join(" "));
        });
    }
```

#### 61. 扑克牌大小
```javascript
   while ((line = await readline())) {
        // 通过数组的索引确定牌的大小顺序
        const compare = ["3","4","5","6","7","8","9","T","J","Q","K","A","2",];

        // 得到两副牌
        const arr = line.split("-");
        let [x, y] = [arr[0], arr[1]];

        if (x.indexOf("j") !== -1 || y.indexOf("j") !== -1) {
            // 如果有副牌中有大小王，则直接输出大小王
            console.log("joker JOKER");
        } else {
            // 将每张牌中间的空格去除，以方便获取牌的个数
            // 将牌面 10 换成 T -> 因为当类型相同时，需要比较第一个字符确定牌面大小，如果是 10 的话，就会取到 1
            let xTemp = x.replace(/10/g, "T").replace(/ /g, "");
            let yTemp = y.replace(/10/g, "T").replace(/ /g, "");

            // 得到两副牌的个数
            let [xTempLen, yTempLen] = [xTemp.length, yTemp.length];

            if (xTempLen !== yTempLen) {
                // 两副牌个数不相同
                if (xTempLen === 4) {
                    // 第一副牌是炸弹，输出第一副牌
                    console.log(x);
                } else if (yTempLen === 4) {
                    // 第二副牌是炸弹，输出第二副牌
                    console.log(y);
                } else {
                    // 两副牌都没炸弹，类型不同，无法比较
                    console.log("ERROR");
                }
            } else {
                // 两副牌个数相同 -> 类型相同
                if (compare.indexOf(xTemp[0]) > compare.indexOf(yTemp[0])) {
                    // 第一副牌的牌面大
                    console.log(x);
                } else {
                    console.log(y);
                }
            }
        }
    }
```

#### 62. 从单向链表中删除指定值的节点
```javascript
   while ((line = await readline())) {
       let [total, start, ...arr] =line.split(" ").map(Number);
        const rmVal = arr.pop();
        let res = [start];
        for (let i = 0; i < arr.length; i += 2) {
            const val = arr[i];
            const head = arr[i + 1];
            const index = res.findIndex((val) => val === head);
            res.splice(index + 1, 0, val);
        }
        console.log(res.filter((n) => n !== rmVal).join(" "));
    }
    
```

#### 63. 最长回文子串
```javascript
    while ((line = await readline())) {
        console.log(longestPalindrome(line));
    }
    // 中心扩展算法
    function expandAroundCenter(s, left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    function longestPalindrome(s) {
        if (s.length <= 1) return 1 + "";

        let start = 0,
            end = 0;
        for (let i = 0; i < s.length; i++) {
            // 奇数长度回文
            const len1 = expandAroundCenter(s, i, i);
            // 偶数长度回文
            const len2 = expandAroundCenter(s, i, i + 1);
            const maxLen = Math.max(len1, len2);

            if (maxLen > end - start) {
                start = i - Math.floor((maxLen - 1) / 2);
                end = i + Math.floor(maxLen / 2);
            }
        }
        return s.substring(start, end + 1).length;
    }
//中心扩展算法的基本思想是：
//1.遍历字符串中的每个字符，将其作为回文中心
//2.向两边扩展，检查字符是否相同
//3.记录最长的回文子串及其长度
//4.考虑奇数和偶数长度的回文情况
```

#### 64. 24点运算
```javascript
    const d = {3: 3,4: 4,5: 5,6: 6,7: 7,8: 8,9: 9,10: 10,J: 11,Q: 12,K: 13,A: 1,2: 2};
    const res = [];
    function f(nums, target) {
        if (nums.length == 1) {
            if (d[nums[0]] == target) {
                res.push(nums[0]);
                return true;
            } else {
                return false;
            }
        }
        for (let i = 0; i < nums.length; i++) {
            const a = nums[i];
            const b = nums.slice(0, i).concat(nums.slice(i + 1));
            if (f(b, target + d[a])) {
                res.push("-" + a);
                return true;
            } else if (f(b, target - d[a])) {
                res.push("+" + a);
                return true;
            } else if (f(b, target * d[a])) {
                res.push("/" + a);
                return true;
            } else if (target % d[a] === 0 && f(b, target / d[a])) {
                res.push("*" + a);
                return true;
            }
        }
        return false;
    }
    function get24(str) {
        var nums = str.split(" ");
        if (nums.includes("joker") || nums.includes("JOKER")) {
            console.log("ERROR");
        } else {
            if (f(nums, 24)) {
                console.log(res.join(""));
            } else {
                console.log("NONE");
            }
        }
    }
    get24(await readline());
```

#### 65. 走迷宫(BFS)
```javascript
    var lines = []
    while ((line = await readline())) {
      lines.push(line)
    }
    let line1 = lines[0].split(" ");
    var n = Number(line1[0]),
        m = Number(line1[1]);
    let line2 = lines[1].split(" ");
    var map = new Array(n);
    for (let i = 0; i < n; i++) {
        map[i] = lines[i + 2].split("");
    }
    let target = false;
    map[Number(line2[0]) - 1][Number(line2[1]) - 1] = 0;
    function bfs(queue) {
        const nextQueute = [];
        if (queue.length === 0) return;
        if (target) return;
        let dep = map[queue[0][0]][queue[0][1]];
        let dx = [0, 0, 1, -1],
            dy = [1, -1, 0, 0];
        for (let j = 0; j < queue.length; j++) {
            for (let i = 0; i < 4; i++) {
                let ni = dx[i] + queue[j][0],
                    nj = dy[i] + queue[j][1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                if (map[ni][nj] === ".") {
                    map[ni][nj] = dep + 1;
                    if (
                        ni === Number(line2[2]) - 1 &&
                        nj === Number(line2[3]) - 1
                    )
                        target = true;
                    nextQueute.push([ni, nj]);
                }
            }
        }
        if (nextQueute.length && !target) bfs(nextQueute);
    }
    let queee = [[Number(line2[0]) - 1, Number(line2[1]) - 1]];
    bfs(queee);
    if (
        map[Number(line2[2]) - 1][Number(line2[3]) - 1] !== "." &&
        map[Number(line2[2]) - 1][Number(line2[3]) - 1] !== "*"
    ) {
        console.log(map[Number(line2[2]) - 1][Number(line2[3]) - 1]);
    } else {
        console.log(-1);
    }
```

#### 66. 放苹果
```javascript
    while ((str = await readline())) {
        let arr = str.split(" ");
        let m = parseInt(arr[0]),
            n = parseInt(arr[1]);
        console.log(getCount(m, n));
    }
    function getCount(m, n) {
        if (m == 0 || n == 1) {
            //极端情况1：都是最小值情况
            return 1;
        } else if (n > m) {
            //极端情况2:盘子比苹果多，那肯定有n-m个盘子空着
            return getCount(m, m);
        } else {
            //极端情况3:范围：[至少一个盘子空着----所有盘子都不空，都有苹果]
            //假设有一个盘子为空，则(m,n)问题转化为将m个苹果放在n-1个盘子上，即求得(m,n-1)即可
            //假设所有盘子都装有苹果，则每个盘子上至少有一个苹果，即最多剩下m-n个苹果，问题转化为将m-n个苹果放到n个盘子上，即求(m-n，n)
            return getCount(m, n - 1) + getCount(m - n, n);
        }
    }
```

#### 66. 数组分组
```javascript
//思想：将能整除3或者5的各自分为一组，记为sum1和sum2，剩余的保存在数组nums里
//现有两组，剩余nums里的数要么在sum1里要么在sum2里，利用递归依次放在sum1和sum2中
//最终nums里的数字全部放进去，若sum1 == sum2，则返回true，否则，返回false
    while ((str = await readline())) {
      let num =await readline();
        let arr = num.split(" ");
        let three = arr.filter((v) => {
            return v % 3 == 0 && v % 5 != 0;
        });

        let five = arr.filter((v) => {
            return v % 5 == 0;
        });

        let other = arr.filter((v) => {
            return v % 5 != 0 && v % 3 != 0;
        });
        //所有三的倍数的数字的和
        let tsum = three.reduce((pre, cur) => {
            return pre + cur * 1;
        }, 0);
        //所有五的倍数的数字的和
        let fsum = five.reduce((pre, cur) => {
            return pre + cur * 1;
        }, 0);

        console.log(isExists(tsum, fsum, other, 0));
    }
     function isExists(sum1, sum2, nums, index) {
        if (index == nums.length && sum1 != sum2) return false;
        if (index == nums.length && sum1 == sum2) return true;
        if (index < nums.length)
            return (
                isExists(sum1 + parseInt(nums[index]), sum2, nums, index + 1) ||
                isExists(sum1, sum2 + parseInt(nums[index]), nums, index + 1)
            );
        return false;
    }
```