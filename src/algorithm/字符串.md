---
title: 字符串
icon: pen-to-square
# sticky: -1
category:
  - 知识点篇
# permalink: /website/
---

<!-- more -->
::: info
此处存放的一些常用字符串方法。
:::

### 核心概念：字符串是不可变的（Immutable）
在大多数语言中，字符串是“不可变”的。这意味着所有字符串方法都不会改变原字符串，而是返回一个新的字符串。
例如：
```python
s = "Hello"
new_s = s.upper() # 返回 "HELLO"
print(s) # 原字符串不变，输出 "Hello"
print(new_s) # 输出 "HELLO"
```
---
```javascript
常用的JavaScript字符串方法包括：
  - charAt(index): 返回指定位置的字符
  - charCodeAt(index): 返回指定位置字符的Unicode编码
  - concat(str1, str2, ...): 连接两个或多个字符串
  - indexOf(searchValue, fromIndex): 返回指定字符串第一次出现的索引
  - lastIndexOf(searchValue, fromIndex): 返回指定字符串最后一次出现的索引
  - match(regexp): 检索匹配项
  - replace(searchValue, replaceValue): 替换匹配的字符串
  - search(regexp): 搜索匹配项
  - slice(startIndex, endIndex): 提取字符串片段
  - split(separator, limit): 将字符串分割为数组
  - substring(startIndex, endIndex): 提取字符串中介于两个索引之间的字符
  - toLowerCase(): 转换为小写
  - toUpperCase(): 转换为大写
  - trim(): 去除两端空白
  - trimStart(): 去除开头空白
  - trimEnd(): 去除结尾空白
  - startsWith(searchString, position): 检查是否以指定字符串开头
  - endsWith(searchString, length): 检查是否以指定字符串结尾
  - includes(searchString, position): 检查是否包含指定字符串
  - repeat(count): 重复字符串
  - padStart(targetLength, padString): 在开头填充
  - padEnd(targetLength, padString): 在结尾填充

    全面的字符串方法分类​：
  - 基础方法（charAt, charCodeAt, concat）
  - 搜索方法（indexOf, lastIndexOf, includes）
  - 提取方法（slice, substring, substr）
  - 修改方法（replace, split）
  - 大小写转换（toLowerCase, toUpperCase）
  - 空白处理（trim, trimStart, trimEnd）
  - 其他方法（startsWith, endsWith, repeat）
```
### 一、Python 字符串方法
#### 1. 大小写转换
- .upper(): 转换为大写
- .lower(): 转换为小写
- .capitalize(): 首字母大写
- .title(): 每个单词首字母大写
- .swapcase(): 大小写互换
#### 2. 查找和替换
- .find(sub) / .index(sub): 查找子串，返回索引（找不到时，find 返回 -1，index 抛出异常）
- .rfind(sub) / .rindex(sub): 从右边开始查找
- .replace(old, new[, count]): 替换子串（count 可指定替换次数）
- .count(sub): 统计某个子串出现的次数
#### 3. 字符串判断（返回 True 或 False）
- .startswith(prefix): 是否以某子串开头
- .endswith(suffix): 是否以某子串结尾
- .isalpha(): 是否所有字符都是字母
- .isdigit(): 是否所有字符都是数字
- .isalnum(): 是否所有字符都是字母或数字
- .isspace(): 是否所有字符都是空白符（空格、换行、制表符等）
- .islower(): 是否所有字符都是小写
- .isupper(): 是否所有字符都是大写
#### 4. 分割和连接
- .split(sep=None): 根据分隔符（默认为所有空白符）分割字符串，返回列表
- .splitlines(): 按行分割
- .join(iterable): 用原字符串作为连接符，将可迭代对象（如列表）中的元素连接成一个新字符串
```python
lst = ["Python", "is", "great"]
s = " ".join(lst) # 输出 "Python is great"
```
#### 5. 去除空白和填充
- .strip([chars]): 去除左右两侧的指定字符（默认为空白符）
- .lstrip([chars]): 去除左侧的指定字符
- .rstrip([chars]): 去除右侧的指定字符
- .zfill(width): 用 0 在左边填充字符串，使其达到指定长度
- .center(width[, fillchar]): 将字符串居中，并用指定字符（默认为空格）填充至长度 width
#### 6. 格式化
- .format(): 格式化字符串的现代方式（推荐）
```python
"Hello, {}!".format("World") # 输出 "Hello, World!"
```
- f-string (Python 3.6+): 更简洁的格式化方法
```python
name = "World"
s = f"Hello, {name}!" # 输出 "Hello, World!"
```
---

### 二、JavaScript 字符串方法
JavaScript 的方法与 Python 非常相似，但语法上是小驼峰命名（camelCase）。
#### 1. 大小写转换
- .toUpperCase(): 转换为大写
- .toLowerCase(): 转换为小写
#### 2. 查找和替换
- .indexOf(searchValue) / .lastIndexOf(): 查找子串，返回索引（找不到返回 -1）
- .includes(searchValue): 判断是否包含子串（返回 true/false）
- .startsWith(searchValue) / .endsWith(): 判断开头/结尾
- .replace(searchValue, newValue): 替换第一个匹配的子串
- .replaceAll(searchValue, newValue): (ES2021) 替换所有匹配的子串
#### 3. 分割和连接
- .split(separator): 分割字符串，返回数组
- .concat(str2, ...): 连接字符串（通常更常用 + 或模板字符串）
- .repeat(count): 将字符串重复 count 次并返回
#### 4. 截取和获取
- .slice(start, end): 提取子串（支持负数索引）
- .substring(start, end): 提取子串（类似 slice，但不支持负数）
- .substr(start, length):（已废弃）不推荐使用
- .charAt(index): 获取指定位置的字符
- .charCodeAt(index): 获取指定位置字符的 Unicode 编码
#### 5. 去除空白
- .trim(): 去除左右两侧空白
- .trimStart() / .trimEnd(): 去除左侧或右侧空白
#### 6. 格式化
- 模板字符串（Template literals） (ES6): 使用反引号 ` 和 ${} 插入变量
```javascript
const name = "World";
const s = `Hello, ${name}!`; // 输出 "Hello, World!"
```
---

### 总结与建议
|功能|Python 方法|JavaScript 方法|
|--|--|--|
|转大写|upper()|toUpperCase()|
|查找索引|find() / index()|indexOf()|
|替换|replace()|replace() / replaceAll()|
|分割|split()|split()|
|连接数组|join()|concat() 或 +|
|去除空白|strip()|trim()|
|判断开头|startswith()|startsWith()|
|格式化|f"{}" / format()|` ${} `|

最佳实践：
1. 查阅官方文档：这是最权威、最全面的方法。遇到不确定的用法，随时搜索 “MDN String” (JavaScript) 或 “Python string methods”。
1. 注意语言差异：虽然功能相似，但方法名和参数细节（如 slice 和 substring 的区别）需要特别注意。
1. 多练习：字符串处理是编程基本功，多写代码是掌握它们的最好方式。

<test></test>

### 字符串操作方法
#### 1.字符串最后一个单词的长度
```javascript
const fun=(arr)=>{
    const arr=arr.split(' ')
    return arr[arr.length -1].length
}
console.log(fun('helloWolrd'))//10
console.log(fun('A b C 123 D')) // 1
// 或者
const fun=(arr)=>{
    const arr=arr.split(' ')
    return arr.pop().length //返回删除元素的长度
}
```
#### 2.计算某字符出现次数
```javascript
const dn=(str,substr)=>{
//转换为小写保持格式一直，避免判断的时候由于输入出现问题
 const arr=str.toLowerCase().split(substr.toLowerCase()).length -1
}
console.log(dn('hwe333','3'))//3
```

#### 3.字符串分隔
```javascript
//8个字符为一行，不足8个字符用0补足
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void async function () {
    while (line = await readline()) {
        var str = line + '00000000';
        for (let i = 8; i < str.length; i += 8) {
            console.log(str.substring(i - 8, i));
        }
    }
    //或者
     while (line = await readline()) {
        const overNumber = line.length % 8
        const result = line.concat(new String("0").repeat(overNumber ? 8 - overNumber : 0))
        for (let i = 0; i < result.length;) {
            console.log(result.substring(i, i += 8))
        }
    }
}()
//输入'helloworld',输出：hellowor，ld000000
```

#### 4.进制转换
```javascript
//将16进制转换为10进制
//说明：回忆十六进制转化为十进制的方法：从右往左，将第 i 位乘以 16的i次方，然后求和。
parseInt()是 ​JavaScript​ 中的一个全局函数，它的主要作用是将一个字符串解析成一个整数。如果无法解析，则返回 NaN。
parseInt(input, 16)
```

#### 5.字符个数统计
```javascript
//对于字符串个数统计的问题，先将字符串转换为数组，再将数组去重，剩下的就是不同字符串个数
while(line = await readline()){
    const arr=line.split('')
    const num=(Array.from(new Set(arr))).length
    console.log(num)
}
//输入：[@A8aA].0，输出：8
```

#### 6.字符数字颠倒
```javascript
//对于字符串个数统计的问题，先将字符串转换为数组，再将数组去重，剩下的就是不同字符串个数
while(line = await readline()){
    var str=''
       for(let i=0;i<line.length;i++){
        str+=line[line.length-1-i]
       }
       console.log(str)
    //或者
    const sub=[...line].reverse().join('')//利用结构赋值，把字符串里面每个对象转换为数组
}
//输入：1516000，输出：0006151
```

#### 7.字符串中找出连续最长的数字串
```javascript
//对于字符串个数统计的问题，先将字符串转换为数组，再将数组去重，剩下的就是不同字符串个数
while(line = await readline()){
    let dt = "";
        line.split('').forEach(item => {
            if (/^[0-9]*$/.test(item) && item !== '') {
                dt += item;
            } else {
                dt += ',';
            }
        })

        let num = 0;
        let out = '';
        dt.split(',').forEach((item, index) => {
            if (item.length > num) {
                num = item.length
                out = item;
            }
        });
        console.log(out);
}
//输入：abcd12345678910ed125ss123456789，输出：12345678910
```

#### 8.字符串排序
```javascript
//按照字母顺序a->b，从小到大
while(line = await readline()){
    let arr = []
    while ((line = await readline())) {
        arr.push(line)
    }
    arr.sort()
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i])
    }
}
//输入：zbcpa，输出：abcpz
```

#### 9.查找无重复最长子串
```javascript
while(line = await readline()){
    let start = 0,
    maxLength = 0,
    maxStart = 0;
    let charMap = new Map();
    for (let end = 0; end < line.length; end++) {
        let char = line[end];
        if (charMap.has(char) && charMap.get(char) >= start) {
            start = charMap.get(char) + 1;
        }
        charMap.set(char, end);
        if (end - start + 1 > maxLength) {
            maxLength = end - start + 1;
            maxStart = start;
        }
    }
    console.log(maxLength)
   return {
     substring:line.substring(maxStart ，maxStart + maxLength),//返回对应的字符串
     length:maxLength//返回的字符串对于的最大长度
   }
}
//输入：zbcpa，输出：5,输入：pwwkew，输出：3
```

#### 10.坐标移动
```javascript
while(line = await readline()){
//不使用正则的解法，只使用于长度小于等于3的字符类型
let x = 0
let y = 0
let strs=line.split(';')
for (let i = 0; i < strs.length; i++) {
    let str = strs[i]
    let num = Number(str.slice(1))
    if (str.length <= 3 && str.length > 1 && !isNaN(num)) {
        if (str[0] === 'A') {
            x -= num
        } else if (str[0] === 'D') {
            x += num
        } else if (str[0] === 'W') {
            y += num
        } else if (str[0] === 'S') {
            y -= num
        }
    }
}
console.log([x,y].join(','))

//使用正则的解法
var arr = [];
    var newLineArr = line.split(";");
    var reg = /^(A|D|W|S){1}[0-9]{1,2}$/;
    // print(reg.test("A11"));
    for (var i = 0; i < newLineArr.length; i++) {
        if (reg.test(newLineArr[i])) {
            arr.push(newLineArr[i]);
            //         print(newLineArr[i]);
        }
    }
    var x = 0;
    var y = 0;
    for (var j = 0; j < arr.length; j++) {
        var dir = arr[j].charAt(0);
        var step = Number(arr[j].slice(1));
        //     print(dir,step);
        switch (dir) {
            case "A":
                x = x - step;
                break;
            case "D":
                x = x + step;
                break;
            case "W":
                y = y + step;
                break;
            case "S":
                y = y - step;
                break;
            default:
                x = x + 0;
                break;
        }
    }
    var reslut = [x, y];
    var strR = reslut.join(",");
    console.log(strR)
}
//输入：zbcpa，输出：abcpz
```

#### 11.删除字符串中出现次数最少的字符
```javascript
while(line = await readline()){
    let obj = {};
    let res = "";
    let str=line
    for (let i = 0; i < str.length; i++) {
        if (obj[str[i]]) obj[str[i]]++;
        else obj[str[i]] = 1;
    }
    let min = Math.min(...Object.values(obj));
    for (let i = 0; i < str.length; i++) {
        if (obj[str[i]] !== min) res += str[i];
        else res=''
    }
    console.log(res);
}
//输入：aabcddd，输出：aaddd
```

#### 12.密码验证合格程序
```javascript
while(line = await readline()){
   const list = [].push(line)

for(let itm of list){
    if(!(/.{9,}/.test(itm))){//任意字符且长度大于等于9
        console.log('NG');
        continue;
    }
    let sum = 0;
    if(/[a-z]/.test(itm))sum++
    if(/[A-Z]/.test(itm))sum++
    if(/[\d]/.test(itm))sum++
    if(/[^\da-zA-Z]/.test(itm))sum++ //匹配任何不是数字也不是字母的字符，匹配特殊字符
    
    if(sum<3){
        console.log('NG');
        continue;
    }
    if(/(.{3,}).*\1/g.test(itm)){//匹配任何重复出现的至少 3 个字符的子串，且两次出现之间可以有任意字符
        console.log('NG');
    }else {
        console.log('OK');
    }
    
}

}

```

#### 13.简单密码
```javascript
while(line = await readline()){
    let strArr = [...line];
        let res = [];
        for (let v of strArr) {
            //如果是大写字母
            if (/[A-Z]/.test(v)) {
                if (v.toLowerCase() === "z") {
                    v = "a";
                } else {
                    v = v.toLowerCase().charCodeAt(0) + 1;//往后挪一个，charCodeAt()将字符转换为 Unicode 编码（整数）
                    v = String.fromCharCode(v);//将加 1 后的 Unicode 编码转换回对应的字符
                }

                res.push(v);
            } else if (/[a-z]/.test(v)) {
                //如果是小写字母
                if ("abc".split("").includes(v)) {
                    v = 2;
                } else if ("def".split("").includes(v)) {
                    v = 3;
                } else if ("ghi".split("").includes(v)) {
                    v = 4;
                } else if ("jkl".split("").includes(v)) {
                    v = 5;
                } else if ("mno".split("").includes(v)) {
                    v = 6;
                } else if ("pqrs".split("").includes(v)) {
                    v = 7;
                } else if ("tuv".split("").includes(v)) {
                    v = 8;
                } else if ("wxyz".split("").includes(v)) {
                    v = 9;
                }
                res.push(v);
            } else {
                res.push(v);
            }
        }
        console.log(res.join(''))
}

```

#### 14.字符串排序
```javascript
while(line = await readline()){
    let arr = line.split("");
    let sorted = [];
    for (let i = 0; i < 26; i++) {//这段代码将字母排序
        for (let j = 0; j < arr.length; j++) {
            if (
                arr[j].charCodeAt(0) == 65 + i ||
                arr[j].charCodeAt(0) == 97 + i
            ) {
                sorted.push(arr[j]);
            }
        }
    }
    for (let i = 0; i < arr.length; i++) {
        if (!/[A-Za-z]/g.test(arr[i])) {//表示除了字母以外的字符正常显示
            sorted.splice(i, 0, arr[i]);
        }
    }
    console.log(sorted.join(""));
}
// 输入：BabA，输出：aABb
```

#### 15.查找兄弟单词
```javascript
while(line = await readline()){
     let argArr=line.split(' ')
        let j = 0;
        let num = argArr[j++] - 0;
        let arrs = [];
        let findArr = [];
        let sum = 0;
        for (let i = 0; i < num; i++) {
            let line = argArr[j++];
            arrs.push(line);
        }
        let target = argArr[j++];
        let k = argArr[j++];
        for (let i = 0; i < num; i++) {
            if (
                arrs[i] !== target &&
                arrs[i].split("").sort().join("") ===
                    target.split("").sort().join("")
            ) {
                sum++;
                findArr.push(arrs[i]);
            }
        }
        findArr = findArr.sort();
        console.log(sum);
        if (findArr[k - 1]) {
            console.log(findArr[k - 1]);
        }
}
```

#### 16.字符串加解密
```javascript
let i=0;
while(line = await readline()){
    i++;
    let type = i % 2 == 0;
    let arr = line.split("");
    let newArr = [];
    arr.forEach((str) => {
        if (/[a-z]/.test(str)) {
            if (type) {
                if (str == "a") {
                    newArr.push("Z");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toUpperCase().charCodeAt(0) - 1
                        )
                    );
                }
            } else {
                if (str == "z") {
                    newArr.push("A");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toUpperCase().charCodeAt(0) + 1
                        )
                    );
                }
            }
        } else if (/[A-Z]/.test(str)) {
            if (type) {
                if (str == "A") {
                    newArr.push("z");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toLowerCase().charCodeAt(0) - 1
                        )
                    );
                }
            } else {
                if (str == "Z") {
                    newArr.push("a");
                } else {
                    newArr.push(
                        String.fromCharCode(
                            str.toLowerCase().charCodeAt(0) + 1
                        )
                    );
                }
            }
        } else if (/[0-9]/.test(str)) {
            if (type) {
                if (str == "0") {
                    newArr.push("9");
                } else {
                    newArr.push(+str - 1);
                }
            } else {
                if (str == "9") {
                    newArr.push("0");
                } else {
                    newArr.push(+str + 1);
                }
            }
        } else {
            newArr.push(str);
        }
    });
    console.log(newArr.join(""));
}

```

#### 17.单词倒序
```javascript
 while (line = await readline()) {
        //通过正则表达式分隔
        var arr = line.split(/[^A-Za-z]+/).reverse().join(' ')
        console.log(arr);
        //或者替换
        let str = line
        let str2 = str.replace(/[^a-zA-Z]+/g, ' ');
        let arr = str2.split(' ').reverse();
        console.log(arr.join(' '));
    }
//输入：Nowcoder Hello ，输出：Hello Nowcoder
//输入：$bo*y gi!r#l ，输出：l r gi y bo
```

#### 18.密码截取
```javascript
 while (line = await readline()) {
    let res = [];
    for (let i = 0; i < line.length; i++) {
        let temp = [];
        if (line[i] === line[i + 1]) {
            temp = [line[i], line[i + 1]];
            temp = getPsd(temp, i - 1, i + 2);
            res = temp.length > res.length ? temp : res;
        }
        temp = [line[i]];
        temp = getPsd(temp, i - 1, i + 1);
        res = temp.length > res.length ? temp : res;
    }
    console.log(res.length);

    function getPsd(arr, i, j) {
        while (i > -1 && j < line.length) {
            if (line[i] === line[j]) {
                arr.unshift(line[i]);
                arr.push(line[j]);
                i--;
                j++;
            } else {
                return arr;
            }
        }
        return arr;
    }
 }
//输入：12HHHHA ，输出：4
//输入：ABBA ，输出：4
```

#### 19.整数与IP地址间的转换
```javascript
var result
while (line = await readline()) {
    if (line.includes(".")) {//将ip地址转化为整数
        result=  toNum(line)
    } else {//将数字转化为ip地址
        result= toIp(line)
    }
    console.log(result)
}
function toIp(num) {
    const str = Number(num).toString(2).padStart(32, "0")
    const arr = [str.slice(0, 8), str.slice(8, 16), str.slice(16, 24), str.slice(24, 32)]
    const ip = arr.map(ele => parseInt(ele, 2)).join(".")
    return (ip)
}

function toNum(ip) {
    const arr = ip.split(".").map(ele => Number(ele).toString(2)).map(ele => ele.padStart(8, "0"))
    const num = arr.join("")
    return (parseInt(num, 2))
}

```

#### 20.密码截取
```javascript
 while (line = await readline()) {
        //通过正则表达式分隔
        var arr = line.split(/[^A-Za-z]+/).reverse().join(' ')
        console.log(arr);
        //或者替换
        let str = line
        let str2 = str.replace(/[^a-zA-Z]+/g, ' ');
        let arr = str2.split(' ').reverse();
        console.log(arr.join(' '));
    }
//输入：Nowcoder Hello ，输出：Hello Nowcoder
//输入：$bo*y gi!r#l ，输出：l r gi y bo
```

#### 21.字符串加密（待）
```javascript
 while (line = await readline()) {
    var key = readline();
    var msg = readline();
    var line = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ').toLocaleLowerCase();
    var set = new Set(key + line);
    var list = new Array(...set);
    var final = '';
    for (var i = 0; i < msg.length; i++) {
        var index = line.indexOf(msg[i]);
        var mi = list[index];
        final += mi[0];
    }
    console.log(final);
}

```

#### 22.统计字符
```javascript
 while (line = await readline()) {
    //对于给定的由可见字符和空格组成的字符串，统计其中英文字母、空格、数字和其它字符的个数。
    let str = line;
    let a = str.replace(/[^a-zA-Z]+/g, "");
    let b = str.replace(/[^\s]+/g, "");
    let c = str.replace(/[^0-9]+/g, "");
    let d = str.replace(/[a-zA-Z0-9\s]+/g, "");
    console.log(a.length);
    console.log(b.length);
    console.log(c.length);
    console.log(d.length);
    }

```
#### 23. 称砝码（待）
```javascript
 while (line = await readline()) {
    //对于给定的n种砝码，现在要用这些砝码去称物体的重量（放在同一侧），问能称出多少种不同的重量，
    let line1 = readline();let line2 = readline();let line3 = readline();
    let m = line2.split(' '); //每种砝码的重量
    let x = line3.split(' '); //每种砝码对应的数量范围
    let fama = []            //序列化砝码，比如两个1g和一个2g的砝码用[1,1,2]表示
    for (let i = 0; i < m.length; i++) {
      for (let j = 0; j < x[i]; j++) {
        fama.push(Number(m[i]))
       }
    }
    let kind = new Set();    //用set表示加入当前砝码之前能产生的重量种类
    kind.add(0);            //set初始化为0
    // 当第一个1g砝码放入时，set中要插入原先所有元素+1g后的结构，即{0,0+1}，插入后变为{0,1}
    // 当第二个1g砝码放入时，set要插入{0+1,1+1},变为{0,1,2}
    // 第三个2g砝码放入时，set要插入{0+2,1+2,2+2},变为{0,1,2,3,4}
    for (let i = 0; i < fama.length; i++) {
        let arr = [...kind]    //用一个数组来缓存当前种类的砝码的值
        for (let k of arr) {
            kind.add(k + fama[i]);
        }
    }
        console.log(kind.size)
    }

```

#### 24.  四则运算
```javascript
//使用eval()函数
 while (line = await readline()) {
    let  a = line.replace('{','(').replace('}',')')
    console.log(eval(a))
    }
//输入：3+2*{1+2*[-4/(8-6)+7]}，输出:25
```

#### 25.  计算字符串的编辑距离
```javascript
void (async function () {
    // Write your code here
    let lines = [];
    while ((line = await readline())) {
        lines.push(line);
        if (lines.length === 2) {
            const a = lines[0];
            const b = lines[1];
            const distance = calculateEditDistance(a, b);
            console.log(distance);
            lines = []; // 重置lines以处理下一组输入
        }
        function calculateEditDistance(a, b) {
            const m = a.length;
            const n = b.length;

            // 创建DP数组
            const dp = new Array(m + 1);
            for (let i = 0; i <= m; i++) {
                dp[i] = new Array(n + 1).fill(0);
            }

            // 初始化边界条件
            for (let i = 0; i <= m; i++) {
                dp[i][0] = i;
            }
            for (let j = 0; j <= n; j++) {
                dp[0][j] = j;
            }

            // 填充DP表
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (a[i - 1] === b[j - 1]) {
                        // 字符相同，不需要操作
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        // 取三种操作的最小值加1
                        dp[i][j] = Math.min(
                            dp[i - 1][j] + 1, // 删除操作
                            dp[i][j - 1] + 1, // 插入操作
                            dp[i - 1][j - 1] + 1 // 替换操作
                        );
                    }
                }
            }

            return dp[m][n];
        }
    }
})();

```

#### 26.  高精度整数加法
```javascript
void (async function () {
    // Write your code here
    let lines = [];
    while ((line = await readline())) {
        lines.push(line.trim());
        if (lines.length === 2) {
            const a = lines[0];
            const b = lines[1];
            const sum = addBigIntegers(a, b);
            console.log(sum);
            lines = []; // 重置lines以处理下一组输入
        }
        function addBigIntegers(a, b) {
            // 处理特殊情况：其中一个数为空
            if (!a || a === "0") return b;
            if (!b || b === "0") return a;

            // 反转字符串，从个位开始计算
            const aReversed = a.split("").reverse();
            const bReversed = b.split("").reverse();

            const result = [];
            let carry = 0;
            const maxLength = Math.max(aReversed.length, bReversed.length);

            for (let i = 0; i < maxLength; i++) {
                // 获取当前位的数字，如果不存在则为0
                const digitA =
                    i < aReversed.length ? parseInt(aReversed[i]) : 0;
                const digitB =
                    i < bReversed.length ? parseInt(bReversed[i]) : 0;

                // 计算当前位的和（包括进位）
                const sum = digitA + digitB + carry;

                // 计算当前位的值和新进位
                const digit = sum % 10;
                carry = Math.floor(sum / 10);

                // 将当前位的结果存入数组
                result.push(digit);
            }

            // 如果最后还有进位，添加到结果中
            if (carry > 0) {
                result.push(carry);
            }

            // 将结果反转并转换为字符串
            return result.reverse().join("");
        }
    }
})();
```

#### 27.  找出第一个只出现一次的字符。如果不存在，则输出-1
```javascript
    while ((line = await readline())) {
        console.log(outputFirstLetter(line))
    }
    function outputFirstLetter(str) {
        const len = str.length;
        for (let i = 0; i < len; i++) {
            if (str.indexOf(str[i]) === str.lastIndexOf(str[i])) {
                return str[i];
            }
        }
        return -1;
    }
```

#### 28.  DNA序列
```javascript

    let str =await readline();
    let num =parseInt(await readline());
    let result = "";
    let max = 0;
    for (let i = 0; i <= str.length - num; i++) {
        let s = str
            .substr(i, num)
            .split("")
            .filter((item) => item == "C" || item == "G").length;
        if (s > max) {
            result = str.substr(i, num);
            max = s;
        }
    }
    console.log(result);
    
   
```

#### 29.  参数解析
```javascript
    while ((line = await readline())) {
      let str=line;
        let arr;
        arr = [];
        let flag = false;
        let word = "";
        for (let i = 0; i < str.length; i++) {
            if (str[i] === '"') {
                flag = !flag;
            } else if (str[i] == " " && !flag) {
                arr.push(word);
                word = "";
            } else {
                word += str[i];
            }
        }
        arr.push(word);

        console.log(arr.length);
        arr.forEach((el) => {
            console.log(el);
        });
    }
   
```

#### 30.  合法IP
```javascript
    while ((line = await readline())) {
    testIp(line)
    }
     function testIp(ipAddr) {
        const temp = ipAddr.split(".");
        if (temp.length !== 4) return "NO";
        for (let t of temp) {
            if (!t.length) return "NO";
            if (t.length > 3) return "NO";
            if (!/^[0-9]*$/.test(t)) return "NO";
            if (parseInt(t) > 255) return "NO";
            if (t !== "" + parseInt(t)) return "NO";
        }
        return "YES";
    }
   
```

#### 30. 在字符串中找出连续最长的数字串
```javascript
    while ((line = await readline())) {
    testIp(line)
    }
      function deal(s) {
        var arr = s.match(/[0-9]+/g);
        var len = [];
        arr.forEach((item) => {
            len.push(item.length);
        });
        var maxLen = Math.max(...len);
        var res = "";
        arr.forEach((item) => {
            if (item.length == maxLen) {
                res += item;
            }
        });
       return res+','+ maxLen;
    }
   
```

#### 31. 蛇形矩阵
```javascript
    while ((line = await readline())) {
        let row = Number(line);
        let arr = [1];
        for (var i = 2; i < row + 1; i++) {
            //确定第一行
            arr.push(arr[arr.length - 1] + i);
        }
        for (var j = 0; j < row; j++) {
            let str = "";
            arr.slice(j).forEach((item) => {
                str = str + (item - j) + " ";
            });
            console.log(str);
        }
    }
      
```

#### 32. 输入n个整数，输出其中最小的k个
```javascript
    let num = await readline()
    while ((line = await readline())) {
        //    console.log(num)
        //    console.log(line)
        let arr = num.concat(line)
        // console.log(arr)
        let a = Array.from(new Set(arr.trim()))
        let b = a.sort()
        let c = a.slice(1).reduce((cur, next) => {
            if (next < cur[0]) {
                return [next, cur[0]]
            } else if (next < cur[1] && pre !== cur[0]) {
                return [cur[0], pre]
            }
            return cur
        }, [Infinity, Infinity])
        console.log(c.join(' '))
        // console.log([b[1], b[2]].join(' '))

    }
      
```

#### 33. MP3光标位置
```javascript
    let num = await readline();
    while ((line = await readline())) {
        let str = line.split("");
        // 声明存储当前列表和选中歌曲的变量
        let menu = [];
        let se = 1;
        // 根据输入的命令分别处理赋值
        if (num <= 4) {
            menu = [1, 2, 3, 4].slice(0, num);
            str.forEach((i) => {
                if (i === "U") {
                    se === 1 ? (se = num) : (se -= 1);
                } else if (i === "D") {
                    se === num ? (se = 1) : (se += 1);
                }
            });
        } else {
            str.forEach((i) => {
                if (i === "U") {
                    if (se === 1) {
                        se = num;
                        menu = [num - 3, num - 2, num - 1, num];
                    } else {
                        se -= 1;
                        se <= menu[0]
                            ? (menu = [se, se + 1, se + 2, se + 3])
                            : (menu = menu);
                    }
                } else if (i === "D") {
                    if (se === num) {
                        se = 1;
                        menu = [1, 2, 3, 4];
                    } else {
                        se += 1;
                        se >= menu[3]
                            ? (menu = [se - 3, se - 2, se - 1, se])
                            : (menu = menu);
                    }
                }
            });
        }
        console.log(menu.join(" "));
        console.log(se);
    }
```

#### 34. 矩阵乘法
```javascript
    const x = await readline();
    const y = await readline();
    const z = await readline();
    const A = [];
    const B = [];
    const C = [];
    for (let i = 0; i < x; i++) {
        A.push((await readline()).split(" ").map(Number));
    }
    for (let i = 0; i < y; i++) {
        B.push((await readline()).split(" ").map(Number));
    }
    for (let i = 0; i < x; i++) {
        const tmpA = [];
        for (let j = 0; j < z; j++) {
            let num = 0;
            for (let k = 0; k < y; k++) {
                num += A[i][k] * B[k][j];
            }
            tmpA.push(num);
        }
        C.push(tmpA);
    }
    C.forEach((item) => {
        console.log(item.join(" "));
    });
      
```

#### 35. 质数因子
```javascript
     while ((line = await readline())) {
        let num =  line;
        let arr = [];
        function getCode(num) {
            let i = 2,
                tep = num;
            while (i <= tep && i * i <= tep) {
                while (num % i == 0) {
                    arr.push(i);
                    num /= i;
                }
                ++i;
            }
            if (num != 1) {
                arr.push(num);
            }

            return arr;
        }

        let res = getCode(num);
        console.log(res.join(" "));
    }
      
```

#### 36. 统计每个月兔子的总数
```javascript
    while ((line = await readline())) {
    let m = line;
    let sum = 1;
    let a = 0;
    let b = 0;
    for (let i = 2; i < m; i++) {
        sum = sum + a;
        a = b;
        b = sum;
    }
    console.log(sum + a + b);
}
      
```

#### 36. 分数线划定
```javascript
    // 1. 解析数据并排序
    const parsedData = list.map((item) => {
        const [id, score] = item.split(" ");
        return {
            id: parseInt(id),
            score: parseInt(score),
            original: item,
        };
    });

    // 2. 按成绩降序、编号升序排序
    parsedData.sort((a, b) => {
        if (b.score !== a.score) {
            return b.score - a.score;
        }
        return a.id - b.id;
    });

    // 3. 获取第k名的成绩作为阈值
    const thresholdIndex = Math.min(Math.max(1, t), parsedData.length);
    const thresholdScore = parsedData[thresholdIndex].score;

    // 4. 筛选出所有成绩大于等于该阈值的学生
    const result = parsedData
        .filter((student) => student.score >= thresholdScore)
        .map((student) => student.original);
      
```
#### 37. 单词出现频率排序
```javascript
   function findFrequentWords(str, minCount = 3) {
        const words = str.split(" ");
        const frequencyMap = new Map();

        // 统计词频
        for (const word of words) {
            frequencyMap.set(word, (frequencyMap.get(word) || 0) + 1);
        }

        // 筛选并排序
        const frequentWords = Array.from(frequencyMap.entries())
            .filter(([word, count]) => count >= minCount)
            .sort((a, b) => {
                // 频次降序
                if (b[1] !== a[1]) {
                    return b[1] - a[1];
                }
                // 字典序升序
                return a[0].localeCompare(b[0]);
            })
            .map((entry) => entry[0]);

        return frequentWords;
    }
      
```

#### 38. 谐距下标对
```javascript
   function countHarmonicPairs(arrStr) {
        const arr = arrStr.split(" ").map(Number);
        const n = arr.length;
        const bMap = new Map();

        for (let i = 0; i < n; i++) {
            // 计算 b_i = a_i - (i+1)，因为下标从1开始
            const b = arr[i] - (i + 1);
            if (bMap.has(b)) {
                bMap.set(b, bMap.get(b) + 1);
            } else {
                bMap.set(b, 1);
            }
        }

        let count = 0;
        for (const freq of bMap.values()) {
            if (freq > 1) {
                count += (freq * (freq - 1)) / 2;
            }
        }

        return count;
    }
      
```

#### 40. 汽水瓶
```javascript
    //某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）
    //允许向老板借空汽水瓶（但是必须要归还） 即 3个空瓶子 = 1瓶汽水 + 1个空瓶子 即 2个空瓶子  = 1瓶汽水 所以：答案就是 n 除以2 ，之后再取整.
    //Math.floor()向下取整
     while (line = await readline()) {
        line = parseInt(line)
     
        // let outVal = (line - (line % 2)) / 2   
        // console.log(outVal)
        if(line !==0)   console.log(Math.floor(line/2))
         
    }
      
```

#### 41. 求小球在第五次落地时所经历的路程和第五次反弹的高度
```javascript
     while (line = await readline()) {
      var initHeight=parseInt(line)
        var sum = initHeight;
        var height = initHeight / 2;
        for (let i = 0; i < 4; i++) {
            sum += height * 2;
            height /= 2;
        }
        console.log(sum)
        console.log(height)
    }
      
```

#### 41. 求小球在第五次落地时所经历的路程和第五次反弹的高度
```javascript
     while (line = await readline()) {
      var initHeight=parseInt(line)
        var sum = initHeight;
        var height = initHeight / 2;
        for (let i = 0; i < 4; i++) {
            sum += height * 2;
            height /= 2;
        }
        console.log(sum)
        console.log(height)
    }
      
```

#### 42. 对于给定的数列，直接求解出省略了多少数字
```javascript
     while (line = await readline()) {
    // 使用正则表达式匹配字符串中的所有数字
    let  numMatches = line.match(/\d+/g);
    // 将匹配的数字字符串转换为数字数组
    const numbers = numMatches.map(Number);
    const start = numbers[0]; // 序列起始数字
    const end = numbers[numbers.length - 1]; // 序列结束数字
    const totalNumbers = end - start + 1; // 计算从起始到结束的总数字个数
    const omittedCount = totalNumbers - numbers.length; // 计算被省略的数字个数
    }
      
```

#### 43. 密码强度等级
```javascript
     while (line = await readline()) {
        solution(line)
    }
    function solution(str) {
        let score = 0;

        // 密码长度
        if (str.lenght <= 4) {
            score += 5;
        } else if (str.length <= 7) {
            score += 10;
        } else {
            score += 25;
        }
        let lowerCaseCharNum = 0; //英文小写字母
        let upperCaseCharNum = 0; //英文大写字母
        let numberNum = 0; //数字个数
        let otherNum = 0; //符号

        // 每种字符可能的长度
        for (let i = 0; i < str.length; i++) {
            let char = str.charAt(i);
            if (/[a-z]/.test(char)) {
                lowerCaseCharNum++;
            } else if (/[A-Z]/.test(char)) {
                upperCaseCharNum++;
            } else if (/[1-9]/.test(char)) {
                numberNum++;
            } else if (isOtherChar(char)) {
                otherNum++;
            }
        }

        // 字母
        if (!lowerCaseCharNum && !upperCaseCharNum) {
            score += 0;
        } else if (lowerCaseCharNum && upperCaseCharNum) {
            score += 20;
        } else {
            score += 10;
        }

        // 数字
        if (numberNum === 1) {
            score += 10;
        } else if (numberNum > 1) {
            score += 20;
        }

        // 符号
        if (otherNum === 1) {
            score += 10;
        } else if (otherNum > 1) {
            score += 25;
        }

        // 奖励
        if (lowerCaseCharNum && upperCaseCharNum && numberNum && otherNum) {
            score += 5;
        } else if (
            (lowerCaseCharNum || upperCaseCharNum) &&
            numberNum &&
            otherNum
        ) {
            score += 3;
        } else if ((lowerCaseCharNum || upperCaseCharNum) && numberNum) {
            score += 2;
        }

        if (score >= 90) {
            return "VERY_SECURE";
        } else if (score >= 80) {
            return "SECURE";
        } else if (score >= 70) {
            return "VERY_STRONG";
        } else if (score >= 60) {
            return "STRONG";
        } else if (score >= 50) {
            return "AVERAGE";
        } else if (score >= 25) {
            return "WEAK";
        }
        return "VERY_WEAK";
    }

    // 判断是否是其他字符
    function isOtherChar(char) {
        let num = parseInt(char.charCodeAt(0));
        if (num >= 0x21 && num <= 0x2f) {
            return true;
        } else if (num >= 0x3a && num <= 0x40) {
            return true;
        } else if (num >= 0x5b && num <= 0x60) {
            return true;
        } else if (num >= 0x7b && num <= 0x7e) {
            return true;
        }
        return false;
    }
      
```

#### 44. 给定区间，判断有K的整数，没有输出-1
```javascript
     while (line = await readline()) {
    let arr = line.split(' ').map(Number)
    let num = arr.pop()
    let start = arr[0];
    let end = arr[arr.length - 1]
    let list = []
    for (let i = start; i < end; i++) {
        list.push(i)
    }
    let isFlag = list.some(item => item % num == 0)
    let result = isFlag ? list.filter(item => item % num == 0) : [-1]
    if (result.length >= 1) console.log(result[0])
    }
    //输入：6 10 3，输出:6或者9中一个，如果没有返回-1
```

#### 45. 输出符合2行2列，总数为3的其中一种矩阵
```javascript
     while (line = await readline()) {
    let arr = (await readline()).split(" ").map(Number);
    let rows = arr[0]; //行数
    let cols = arr[1]; //列数
    let totalSum = arr[2]; //总数
    // console.log(line1)
    if (totalSum < cols) {
        console.log(-1);
    } else {
        // 创建矩阵，所有元素初始化为0
        const matrix = [];
        for (let i = 0; i < rows; i++) {
            matrix.push(Array(cols).fill(0));
        }

        // 确保每行每列至少有一个非零元素
        for (let i = 0; i < Math.min(rows, cols); i++) {
            matrix[i][i] = 1;
        }

        // 处理剩余的行或列
        if (rows > cols) {
            for (let i = cols; i < rows; i++) {
                matrix[i][0] = 1;
            }
        } else if (cols > rows) {
            for (let i = rows; i < cols; i++) {
                matrix[0][i] = 1;
            }
        }

        // 计算当前总和
        let currentSum = 0;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                currentSum += matrix[i][j];
            }
        }

        // 调整总和
        if (currentSum < totalSum) {
            matrix[0][0] += totalSum - currentSum;
        }

        // 格式化输出：每行元素空格分隔，行之间换行
        const output = matrix.map((row) => row.join(" ")).join("\n");
        console.log(output);
    }
}
```

#### 46. 数组由0、1组成，1不相邻，给定一个数n，替换掉n个0，并且不相邻
```javascript
     let a = await readline();
    let arr = (await readline()).split(" ").map(Number);
    let n = parseInt(await readline());
    // 统计当前1的数量
    let currentOnes = arr.filter((x) => x === 1).length;

    // 如果数组全是1，无法再添加
    if (currentOnes === arr.length) return false;

    // 找出所有连续的0序列（空隙）
    let gaps = [];
    let start = -1;

    for (let i = 0; i <= arr.length; i++) {
        if (i < arr.length && arr[i] === 0) {
            if (start === -1) start = i;
        } else {
            if (start !== -1) {
                gaps.push({ start, end: i - 1 });
                start = -1;
            }
        }
    }

    // 计算每个空隙可放置的1的数量
    let maxAdditional = 0;

    for (let gap of gaps) {
        const length = gap.end - gap.start + 1;
        let maxInGap = 0;

        // 检查空隙两侧情况
        const leftBlocked = gap.start > 0 && arr[gap.start - 1] === 1;
        const rightBlocked = gap.end < arr.length - 1 && arr[gap.end + 1] === 1;

        if (leftBlocked && rightBlocked) {
            // 两端都有1 - 最严格的限制
            maxInGap = Math.floor((length - 1) / 2);
        } else if (leftBlocked || rightBlocked) {
            // 一端有1
            maxInGap = Math.floor(length / 2);
        } else {
            // 两端都没有1 - 最宽松的情况
            maxInGap = Math.floor((length + 1) / 2);
        }

        maxAdditional += maxInGap;
    }

    // 检查是否可以达到n个1
    //  maxAdditional >= n? console.log(true):console.log(false)
     console.log( maxAdditional >= n)
```

#### 47. 合并表记录，索引相同，value相加
```javascript
     while ((line = await readline())) {
        let obj = {};
        for (let i = 0; i < parseInt(line); i++) {
            let [k, v] =(await readline()).split(" ");
            // console.log([k,v])
            if (obj[k]) {
                obj[k] += parseInt(v);
            } else {
                obj[k] = parseInt(v);
            }
        }
  
        for (let j in obj) {
            console.log(j + " " + obj[j]);
        }
    }
```

#### 48. 记票统计
```javascript
     let perNum = await readline(); //人数
    let per = (await readline()).split(" "); //具体的人
    let vitNum = await readline(); //总共票数
    let vitPer = (await readline()).split(" "); //投票的内容
    const map = new Map();
    for (let i = 0; i < per.length; i++) {
        map.set(per[i], 0);
    }
    map.set("Invalid", 0);
 
    for (let j = 0; j < vitPer.length; j++) {
        if (map.has(vitPer[j])) {
            map.set(vitPer[j], map.get(vitPer[j]) + 1);
        } else {
            map.set("Invalid", map.get("Invalid") + 1);
        }
    }

    for (const [key, value] of map) {
        console.log(`${key} : ${value}`);
    }
```

#### 49. 实现字通配符*
```javascript 
    let sub = await readline();
    let origin = await readline();
    // console.log(sub,origin)
   
    // 通用方法
    function findPatternMatches(target, pattern) {
        const matches = [];

        // 检查模式中是否包含通配符
        if (!pattern.includes("*")) {
            // 没有通配符 - 直接匹配整个模式
            let pos = target.indexOf(pattern);
            while (pos !== -1) {
                matches.push({
                    start: pos,
                    length: pattern.length,
                    substring: pattern,
                    prefixLength: pattern.length,
                    suffixLength: 0,
                });
                pos = target.indexOf(pattern, pos + 1);
            }
            return matches;
        }

        // 拆分模式为前缀和后缀
        const starIndex = pattern.indexOf("*");
        const prefix = pattern.substring(0, starIndex);
        const suffix = pattern.substring(starIndex + 1);

        // 处理特殊情况：模式为 "*"（匹配所有子串）
        if (prefix === "" && suffix === "") {
            // 匹配所有子串（包括空串）
            for (let start = 0; start <= target.length; start++) {
                for (
                    let length = 0;
                    length <= target.length - start;
                    length++
                ) {
                    matches.push({
                        start,
                        length,
                        substring: target.substring(start, start + length),
                        prefixLength: 0,
                        suffixLength: 0,
                    });
                }
            }
            return matches;
        }

        // 查找所有前缀出现的位置
        const prefixPositions = [];
        let prefixIndex = target.indexOf(prefix);
        while (prefixIndex !== -1) {
            prefixPositions.push(prefixIndex);
            prefixIndex = target.indexOf(prefix, prefixIndex + 1);
        }

        // 查找所有后缀出现的位置
        const suffixPositions = [];
        let suffixIndex = target.indexOf(suffix);
        while (suffixIndex !== -1) {
            // 确保后缀完整匹配
            if (suffixIndex + suffix.length <= target.length) {
                suffixPositions.push(suffixIndex);
            }
            suffixIndex = target.indexOf(suffix, suffixIndex + 1);
        }

        // 处理前缀为空的情况（模式为 "*suffix"）
        if (prefix === "") {
            for (const suffixPos of suffixPositions) {
                for (let start = 0; start <= suffixPos; start++) {
                    const length = suffixPos + suffix.length - start;
                    matches.push({
                        start,
                        length,
                        substring: target.substring(start, start + length),
                        prefixLength: 0,
                        suffixLength: suffix.length,
                    });
                }
            }
            return matches;
        }

        // 处理后缀为空的情况（模式为 "prefix*"）
        if (suffix === "") {
            for (const prefixPos of prefixPositions) {
                for (
                    let length = prefix.length;
                    length <= target.length - prefixPos;
                    length++
                ) {
                    matches.push({
                        start: prefixPos,
                        length,
                        substring: target.substring(
                            prefixPos,
                            prefixPos + length
                        ),
                        prefixLength: prefix.length,
                        suffixLength: 0,
                    });
                }
            }
            return matches;
        }

        // 处理一般情况（模式为 "prefix*suffix"）
        for (const prefixPos of prefixPositions) {
            for (const suffixPos of suffixPositions) {
                // 后缀必须在前缀之后
                if (suffixPos >= prefixPos + prefix.length) {
                    const start = prefixPos;
                    const length = suffixPos + suffix.length - prefixPos;
                    matches.push({
                        start,
                        length,
                        substring: target.substring(
                            prefixPos,
                            suffixPos + suffix.length
                        ),
                        prefixLength: prefix.length,
                        suffixLength: suffix.length,
                    });
                }
            }
        }

        return matches;
    }
    findPatternMatches(origin, sub).map(item => {
        console.log(`${item.start} ${item.length}`)
    })



    //例子(写死)
    function findPatternMatches(str) {
        const matches = [];

        // 遍历字符串中的每个字符
        for (let i = 0; i < str.length; i++) {
            // 如果当前字符是 'o'
            if (str[i] === "o") {
                // 从当前位置向后查找所有 'm'
                for (let j = i + 1; j < str.length; j++) {
                    if (str[j] === "m") {
                        // 计算子串长度
                        const length = j - i + 1;
                        // 记录匹配结果
                        matches.push({
                            start: i,
                            length: length,
                            substring: str.substring(i, j + 1),
                        });
                    }
                }
            }
        }

        // 按起始位置升序排序，相同起始位置按长度升序排序
        matches.sort((a, b) => {
            if (a.start !== b.start) {
                return a.start - b.start;
            }
            return a.length - b.length;
        });

        return matches;
    }

    // 查找匹配
    const matches = findPatternMatches(origin);

    // 输出结果
    if (matches.length === 0) {
        console.log("-1 0");
    } else {
        for (const match of matches) {
            console.log(`${match.start} ${match.length}`);
        }
    }
```

#### 50.  简单错误记录
```javascript
     let obj={}
    while (line = await readline()) {
        let str=line
        const [c, n] = str.split(" ");
        const s = c.substr(c.lastIndexOf('\\') + 1).substr(-16)
        obj[`${s} ${n}`] = (obj[`${s} ${n}`] || 0) + 1
    }

    Object.keys(obj).slice(-8).forEach(el => {
        console.log(`${el} ${obj[el]}`)
    })
```


#### 51.  数据分类处理
```javascript
      while ((line = await readline())) {
        let str=line
        let IArr = str.split(" "); //拆分得到I序列
        let RArr =(await readline()).split(" "); //拆分得到R序列
        IArr.shift(); //删除数组第一位，下同
        RArr.shift();
        RArr = [...new Set(RArr.sort((a, b) => a - b))]; //利用Set去重，同时排序，重新赋值给RArr
        let log = []; //定义输出数组
        RArr.forEach((item) => {
            //对R序列的每一项
            let itemArr = []; //定义临时数组
            for (let i = 0; i < IArr.length; i++) {
                if (IArr[i].includes(item)) {
                    //查找包含R单项的I序列项
                    itemArr.push(i, IArr[i]); //若找到，在临时数组中保存下标和I序列单项
                }
            }
            if (itemArr.length !== 0) {
                //如果临时数组长度大于0
                log.push(item, itemArr.length / 2, ...itemArr); //输出数组中加入R单项，I序列中符合条件的个数，并把保存的临沭数组扩展进来
            }
        });
        log.unshift(log.length); //统计输出数组的长度，并将该数字添加到输出数组的第一位
        console.log(log.join(" "));
    }
```

#### 52.  杨辉三角的变形
```javascript
     let obj={}
    while (line = await readline()) {
       const n = Number(line);
        if (n == 1 || n == 2) {
            console.log("-1");
        } else {
            if (n % 4 == 1 || n % 4 == 3) {
                console.log("2");
            } else if (n % 4 == 2) {
                console.log("4");
            } else if (n % 4 == 0) {
                console.log("3");
            }
        }
    }

```

#### 53.  挑7
```javascript
     let obj={}
    while (line = await readline()) {
       let word=line
        word = parseInt(word, 10);
        let arr = [];
        for (var i = 1; i <= word; i++) {
            ((i + "").includes("7") || !(i % 7)) && arr.push(i);
        }
        console.log(arr.length);
    }
    //输入：20，输出：3  与7有关的3个
```

#### 54. 完全数计算
```javascript
    while (line = await readline()) {
      let num=line
        let count = 0; //计数变量
        //第一个完全数是6，若小于6则输出0
        if (num < 6) {
            console.log(0);
        }
        for (let t = 6; t <= num; t++) {
            let sum = 0;
            //统计因数的和，计数到该数的1/2即可
            for (let i = 1; i <= t / 2; i++) {
                if (t % i == 0) sum += i;
            }
            if (sum == t) count++;
        }
        console.log(count);
    }
    //输入：20，输出：3  与7有关的3个
```

#### 55. 查找组成一个偶数最接近的两个素数
```javascript
    while (line = await readline()) {
      let n=line;
        function isPrime(num) {
            for (let i = 2; i <= Math.sqrt(num); i++) {
                console.log(i)
                if (num % i == 0) return false;
            }
            return true;
        }
     
        let num1, num2;
        for (let i = 1; i <= n / 2; i++) {
            if (isPrime(i) && isPrime(n - i)) {
                num1 = i;
                num2 = n - i;
            }
        }
        console.log(num1);
        console.log(num2);
    }
   
```

#### 56. 尼科彻斯定理
```javascript
    while (line = await readline()) {
       let start = line * (line - 1) + 1;
        let res = [];
        for (let i = 0; i < line; i++) {
            res.push(start + i * 2);
        }
        console.log(res.join("+"));
    }
```

#### 57. 将真分数分解为埃及分数
```javascript
  function gcd(a, b) {
        if (a % b === 0) return b;
        return gcd(b, a % b);
    }

    let str;
    while ((str = await readline())) {
        let [a, b] = str.split("/").map(Number);
        let q = 0;
        const ans = [];
        while (a > 1) {
            q = parseInt(b / a);
            ans.push("1/" + (q + 1));
            a = a * (q + 1) - b;
            b = b * (q + 1);
            let maxGcd = gcd(a, b);
            if (maxGcd > 1) {
                a = a / maxGcd;
                b = b / maxGcd;
            }
        }
        ans.push("1/" + b);
        console.log(ans.join("+"));
    }
```

#### 58. 走方格的方案数
```javascript
   while ((line = await readline())) {
        let [n, m] = line.split(' ').map(e => parseInt(e));
        console.log(solution(n, m));
    }
    function solution(n, m) {
        let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1));
        for (let i = 0; i <= n; i++) {
            dp[i][m] = 1;
        }
        for (let j = 0; j <= m; j++) {
            dp[n][j] = 1;
        }
        for (let i = n; i > 0; i--) {
            for (let j = m; j > 0; j--) {
                dp[i - 1][j - 1] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[0][0];
    }
```

#### 59. 矩阵乘法计算量估算(栈)
```javascript
   while ((line = await readline())) {
        let n=parseInt(line)
        // 1. 创建二维数组 arr 保存输入矩阵
        const arr = [];
        for (let i = 0; i < n; i++) {
            arr[i] =(await readline()).trim().split(" ").map(Number);
        }
        // 2. 获取计算法则 method 字符串
        const method =await readline();
        let result = [],
            count = 0; // result 模拟栈结构，保存待计算的数据
        // 3. 遍历计算法则字符串
        for (let i = 0; i < method.length; i++) {
            if (method[i] === "(") {
                // 3.1 遇到前括号不做处理
            } else if (method[i] === ")") {
                // 3.3 当遇到后括号的时候，出栈计算并将结果重新入栈
                if (result.length >= 2) {
                    const second = result.pop();
                    const first = result.pop();
                    count += first[0] * first[1] * second[1];
                    result.push([first[0], second[1]]);
                }
            } else {
                // 遇到非括号，进行入栈操作
                // 通过字母的 ascii 值判断对应矩阵的顺序
                result.push(arr[method.charCodeAt(i) - 65]);
            }
        }
        console.log(count);
    }
```

#### 60. 火车进站（栈）
```javascript
  function dispatch(trains, inOrder, outOrder) {
    if (outOrder.length === num) {
            res.push(parseInt(outOrder.join("")));
        }
        if (trains.length === num) {
            inOrder.push(trains.shift());
            dispatch(trains, inOrder, outOrder);
            return;
        }
        if (trains.length > 0) {
            let cur = trains.shift();
            inOrder.push(cur);
            dispatch(trains, inOrder, outOrder);
            inOrder.pop();
            trains.unshift(cur);
        }
        if (inOrder.length > 0) {
            let cur = inOrder.pop();
            outOrder.push(cur);
            dispatch(trains, inOrder, outOrder);
            outOrder.pop();
            inOrder.push(cur);
        }
    }

    let num;
    let res = [];
    while ((line = await readline())) {
        num = parseInt(line)
        let trains = (await readline()).split(" ");
        let inOrder = [];
        let outOrder = [];
        dispatch(trains, inOrder, outOrder);
        res.sort((a, b) => a - b);
        res.forEach((el) => {
            console.log(el.toString().split("").join(" "));
        });
    }
```

#### 61. 扑克牌大小
```javascript
   while ((line = await readline())) {
        // 通过数组的索引确定牌的大小顺序
        const compare = ["3","4","5","6","7","8","9","T","J","Q","K","A","2",];

        // 得到两副牌
        const arr = line.split("-");
        let [x, y] = [arr[0], arr[1]];

        if (x.indexOf("j") !== -1 || y.indexOf("j") !== -1) {
            // 如果有副牌中有大小王，则直接输出大小王
            console.log("joker JOKER");
        } else {
            // 将每张牌中间的空格去除，以方便获取牌的个数
            // 将牌面 10 换成 T -> 因为当类型相同时，需要比较第一个字符确定牌面大小，如果是 10 的话，就会取到 1
            let xTemp = x.replace(/10/g, "T").replace(/ /g, "");
            let yTemp = y.replace(/10/g, "T").replace(/ /g, "");

            // 得到两副牌的个数
            let [xTempLen, yTempLen] = [xTemp.length, yTemp.length];

            if (xTempLen !== yTempLen) {
                // 两副牌个数不相同
                if (xTempLen === 4) {
                    // 第一副牌是炸弹，输出第一副牌
                    console.log(x);
                } else if (yTempLen === 4) {
                    // 第二副牌是炸弹，输出第二副牌
                    console.log(y);
                } else {
                    // 两副牌都没炸弹，类型不同，无法比较
                    console.log("ERROR");
                }
            } else {
                // 两副牌个数相同 -> 类型相同
                if (compare.indexOf(xTemp[0]) > compare.indexOf(yTemp[0])) {
                    // 第一副牌的牌面大
                    console.log(x);
                } else {
                    console.log(y);
                }
            }
        }
    }
```

#### 62. 从单向链表中删除指定值的节点
```javascript
   while ((line = await readline())) {
       let [total, start, ...arr] =line.split(" ").map(Number);
        const rmVal = arr.pop();
        let res = [start];
        for (let i = 0; i < arr.length; i += 2) {
            const val = arr[i];
            const head = arr[i + 1];
            const index = res.findIndex((val) => val === head);
            res.splice(index + 1, 0, val);
        }
        console.log(res.filter((n) => n !== rmVal).join(" "));
    }
    
```

#### 63. 最长回文子串
```javascript
    while ((line = await readline())) {
        console.log(longestPalindrome(line));
    }
    // 中心扩展算法
    function expandAroundCenter(s, left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    function longestPalindrome(s) {
        if (s.length <= 1) return 1 + "";

        let start = 0,
            end = 0;
        for (let i = 0; i < s.length; i++) {
            // 奇数长度回文
            const len1 = expandAroundCenter(s, i, i);
            // 偶数长度回文
            const len2 = expandAroundCenter(s, i, i + 1);
            const maxLen = Math.max(len1, len2);

            if (maxLen > end - start) {
                start = i - Math.floor((maxLen - 1) / 2);
                end = i + Math.floor(maxLen / 2);
            }
        }
        return s.substring(start, end + 1).length;
    }
//中心扩展算法的基本思想是：
//1.遍历字符串中的每个字符，将其作为回文中心
//2.向两边扩展，检查字符是否相同
//3.记录最长的回文子串及其长度
//4.考虑奇数和偶数长度的回文情况
```

#### 64. 24点运算
```javascript
    const d = {3: 3,4: 4,5: 5,6: 6,7: 7,8: 8,9: 9,10: 10,J: 11,Q: 12,K: 13,A: 1,2: 2};
    const res = [];
    function f(nums, target) {
        if (nums.length == 1) {
            if (d[nums[0]] == target) {
                res.push(nums[0]);
                return true;
            } else {
                return false;
            }
        }
        for (let i = 0; i < nums.length; i++) {
            const a = nums[i];
            const b = nums.slice(0, i).concat(nums.slice(i + 1));
            if (f(b, target + d[a])) {
                res.push("-" + a);
                return true;
            } else if (f(b, target - d[a])) {
                res.push("+" + a);
                return true;
            } else if (f(b, target * d[a])) {
                res.push("/" + a);
                return true;
            } else if (target % d[a] === 0 && f(b, target / d[a])) {
                res.push("*" + a);
                return true;
            }
        }
        return false;
    }
    function get24(str) {
        var nums = str.split(" ");
        if (nums.includes("joker") || nums.includes("JOKER")) {
            console.log("ERROR");
        } else {
            if (f(nums, 24)) {
                console.log(res.join(""));
            } else {
                console.log("NONE");
            }
        }
    }
    get24(await readline());
```

#### 65. 走迷宫(BFS)
```javascript
    var lines = []
    while ((line = await readline())) {
      lines.push(line)
    }
    let line1 = lines[0].split(" ");
    var n = Number(line1[0]),
        m = Number(line1[1]);
    let line2 = lines[1].split(" ");
    var map = new Array(n);
    for (let i = 0; i < n; i++) {
        map[i] = lines[i + 2].split("");
    }
    let target = false;
    map[Number(line2[0]) - 1][Number(line2[1]) - 1] = 0;
    function bfs(queue) {
        const nextQueute = [];
        if (queue.length === 0) return;
        if (target) return;
        let dep = map[queue[0][0]][queue[0][1]];
        let dx = [0, 0, 1, -1],
            dy = [1, -1, 0, 0];
        for (let j = 0; j < queue.length; j++) {
            for (let i = 0; i < 4; i++) {
                let ni = dx[i] + queue[j][0],
                    nj = dy[i] + queue[j][1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                if (map[ni][nj] === ".") {
                    map[ni][nj] = dep + 1;
                    if (
                        ni === Number(line2[2]) - 1 &&
                        nj === Number(line2[3]) - 1
                    )
                        target = true;
                    nextQueute.push([ni, nj]);
                }
            }
        }
        if (nextQueute.length && !target) bfs(nextQueute);
    }
    let queee = [[Number(line2[0]) - 1, Number(line2[1]) - 1]];
    bfs(queee);
    if (
        map[Number(line2[2]) - 1][Number(line2[3]) - 1] !== "." &&
        map[Number(line2[2]) - 1][Number(line2[3]) - 1] !== "*"
    ) {
        console.log(map[Number(line2[2]) - 1][Number(line2[3]) - 1]);
    } else {
        console.log(-1);
    }
```

#### 66. 放苹果
```javascript
    while ((str = await readline())) {
        let arr = str.split(" ");
        let m = parseInt(arr[0]),
            n = parseInt(arr[1]);
        console.log(getCount(m, n));
    }
    function getCount(m, n) {
        if (m == 0 || n == 1) {
            //极端情况1：都是最小值情况
            return 1;
        } else if (n > m) {
            //极端情况2:盘子比苹果多，那肯定有n-m个盘子空着
            return getCount(m, m);
        } else {
            //极端情况3:范围：[至少一个盘子空着----所有盘子都不空，都有苹果]
            //假设有一个盘子为空，则(m,n)问题转化为将m个苹果放在n-1个盘子上，即求得(m,n-1)即可
            //假设所有盘子都装有苹果，则每个盘子上至少有一个苹果，即最多剩下m-n个苹果，问题转化为将m-n个苹果放到n个盘子上，即求(m-n，n)
            return getCount(m, n - 1) + getCount(m - n, n);
        }
    }
```

#### 66. 数组分组
```javascript
//思想：将能整除3或者5的各自分为一组，记为sum1和sum2，剩余的保存在数组nums里
//现有两组，剩余nums里的数要么在sum1里要么在sum2里，利用递归依次放在sum1和sum2中
//最终nums里的数字全部放进去，若sum1 == sum2，则返回true，否则，返回false
    while ((str = await readline())) {
      let num =await readline();
        let arr = num.split(" ");
        let three = arr.filter((v) => {
            return v % 3 == 0 && v % 5 != 0;
        });

        let five = arr.filter((v) => {
            return v % 5 == 0;
        });

        let other = arr.filter((v) => {
            return v % 5 != 0 && v % 3 != 0;
        });
        //所有三的倍数的数字的和
        let tsum = three.reduce((pre, cur) => {
            return pre + cur * 1;
        }, 0);
        //所有五的倍数的数字的和
        let fsum = five.reduce((pre, cur) => {
            return pre + cur * 1;
        }, 0);

        console.log(isExists(tsum, fsum, other, 0));
    }
     function isExists(sum1, sum2, nums, index) {
        if (index == nums.length && sum1 != sum2) return false;
        if (index == nums.length && sum1 == sum2) return true;
        if (index < nums.length)
            return (
                isExists(sum1 + parseInt(nums[index]), sum2, nums, index + 1) ||
                isExists(sum1, sum2 + parseInt(nums[index]), nums, index + 1)
            );
        return false;
    }
```

#### 67. 求int型正整数在内存中存储时1的个数
```javascript
 while ((line = await readline())) {
        let sub = parseInt(line, 10).toString(2);
        let arr = [...sub];
        let cont = 0;
        arr.map((item) => (item == 1 ? cont++ : "0"));
        console.log(cont);
    }
    parseInt(str,radix); 将字符串str按照radix进制编码方式转换为10进制返回，没有radix，  默认为10； 此方法把任意进制字符串转为10进展返回。
     -parseInt(num, 8); //八进制转十进制
     -parseInt(num, 16); //十六进制转十进制
     -parseInt(num).toString(8) - //十进制转八进制
     parseInt(num).toString(16) - //十进制转十六进制
     parseInt(num, 2).toString(8) - //二进制转八进制
     parseInt(num, 2).toString(16) - //二进制转十六进制
     parseInt(num, 8).toString(2); //八进制转二

```

#### 68. 求int型正整数在内存中存储时1的个数
```javascript
 while ((line = await readline())) {
        let sub = parseInt(line, 10).toString(2);
        let arr = [...sub];
        let cont = 0;
        arr.map((item) => (item == 1 ? cont++ : "0"));
        console.log(cont);
    }
    parseInt(str,radix); 将字符串str按照radix进制编码方式转换为10进制返回，没有radix，  默认为10； 此方法把任意进制字符串转为10进展返回。
     -parseInt(num, 8); //八进制转十进制
     -parseInt(num, 16); //十六进制转十进制
     -parseInt(num).toString(8) - //十进制转八进制
     parseInt(num).toString(16) - //十进制转十六进制
     parseInt(num, 2).toString(8) - //二进制转八进制
     parseInt(num, 2).toString(16) - //二进制转十六进制
     parseInt(num, 8).toString(2); //八进制转二

```

#### 69. 百钱买百鸡问题
```javascript
 while ((line = await readline())) {
        //鸡的价值为100
        // 5x + 3y + z/3 = 100;
        // 鸡的只数
        // x + y + z = 100;
        // ==>>> 第一个方程式乘以3
        // 15x + 9y + z = 300;
        // x + y + z = 100;
        // ===>>>两个方程式相减，消除z
        // 14x + 8y = 200 ;
        // ===>
        // 7x + 4y = 100;
        // 因为又满足价值小于 100，假设全部买鸡翁。则最多买 100/7 = 14只。所以  0<=x<=14
        // 根据x求带入方程式7x + 4y = 100;计算出y。根据x ,y带入方程式x + y + z = 100;计算出z;
        let x, y, z;
        for (x = 0; x <= 14; x++) {
            if ((100 - 7 * x) % 4 == 0) {
                y = (100 - 7 * x) / 4;
                z = 100 - x - y;
                console.log(x + " " + y + ' ' + z);
            }
        }
    }

```

#### 70. 字符串末尾是否包含（endsWith）
```javascript
 while ((line = await readline())) {
        let arr = parseInt(line)
        //    console.log(ar)
        let list = []
        for (let i = 0; i <= arr; i++) {
            if((i*i +'').endsWith(i+''))   list.push(i)
          
        }
      console.log(list.length)
    }
//输入：15，输出：0,1,5,6,25
```

#### 71. 预知
```javascript
 let T = parseInt(await readline());
    for (let t = 0; t < T; t++) {
        const n = parseInt(await readline());
        const data = await readline();
        const a = data.split(" ").map(Number);

        if (n === 1) {
            console.log(-1);
            continue;
        }
        let mx = -1;
        for (let i = 0; i < n; i++) {
            if (a[i] > mx) mx = a[i];
        }

        if (mx === 1) {
            console.log(0);
        } else {
            let cnt = 0;
            for (let i = 0; i < n; i++) {
                if (a[i] > 1) cnt++;
            }
            if (cnt === 1) {
                console.log(mx - 1);
            } else {
                console.log(mx);
            }
        }
    }
```

#### 72. 小红的双生排列
```javascript
const  MOD = 1000000007;
 while (line = await readline()) {
        let n = parseInt(line)
        let ans = 1;
        let odds = (n + 1) / 2;  // 奇数个数
        let evens = n / 2;       // 偶数个数

        // 计算奇数排列数
        for (let i = 1; i <= odds; ++i)
        ans = ans * i % MOD;

        // 计算偶数排列数
        for (let i = 1; i <= evens; ++i)
        ans = ans * i % MOD;

        // 当n为偶数时两种模式都有效，需要乘2
        if (n % 2 == 0)
            ans = ans * 2 % MOD;

        console.log( ans);
    }
```

#### 73. 而后单调
```javascript
 const T = parseInt(await readline());

    for (let t = 0; t < T; t++) {
        const data = await readline();
        const [n, m] = data.split(" ").map(Number);

        const a = [0]; // 索引0不使用，从1开始
        const arrData = (await readline()).split(" ").map(Number);
        for (let i = 1; i <= n; i++) {
            a[i] = arrData[i - 1];
        }

        solve(n, m, a);
    }
    function solve(n, m, a) {
        // 创建b数组并排序（从索引1到n）
        const b = [0, ...a.slice(1, n + 1).sort((x, y) => x - y)];

        // 检查是否有重复元素
        for (let i = 2; i <= n; i++) {
            if (b[i] === b[i - 1]) {
                console.log("NO");
                return;
            }
        }
        // 检查递增情况
        for (let i = 1; i <= n - m + 1; i++) {
            let j = i + 1;
            while (
                j <= n &&
                getPos(a[j], b, 1) === getPos(a[j - 1], b, 1) + 1
            ) {
                j++;
            }
            if (j - i >= m) {
                console.log("YES");
                return;
            }
            i = j - 1; // 跳过已检查的部分
        }
        // 反转b数组（递减情况）
        b.reverse();
        b[0] = 0; // 保持索引0不使用

        // 检查递减情况
        for (let i = 1; i <= n - m + 1; i++) {
            let j = i + 1;
            while (
                j <= n &&
                getPos(a[j], b, 2) === getPos(a[j - 1], b, 2) + 1
            ) {
                j++;
            }
            if (j - i >= m) {
                console.log("YES");
                return;
            }
            i = j - 1; // 跳过已检查的部分
        }
        console.log("NO");
    }
    // 二分查找函数
    function getPos(x, b, opt) {
        let l = 1,
            r = b.length - 1;
        let pos = -1;

        while (l <= r) {
            const mid = Math.floor((l + r) / 2);

            if (opt === 1) {
                // 递增情况
                if (b[mid] <= x) {
                    l = mid + 1;
                    pos = mid;
                } else {
                    r = mid - 1;
                }
            } else {
                // 递减情况
                if (b[mid] >= x) {
                    l = mid + 1;
                    pos = mid;
                } else {
                    r = mid - 1;
                }
            }
        }

        return pos;
    }
```

#### 74.  宝石手串
```javascript
const t = parseInt(await readline());

    for (let i = 0; i < t; i++) {
        const n = parseInt(await readline());
        const str = await readline();

        // 处理字符串（去掉可能的换行符）
        const cleanStr = str.trim();

        // 调用处理函数
        const result = findMinDistance(cleanStr);
        console.log(result);
    }
    function findMinDistance(str) {
        // 创建26个字母的位置数组
        const positions = Array(26)
            .fill()
            .map(() => []);

        // 记录每个字符出现的位置
        for (let i = 0; i < str.length; i++) {
            const charCode = str.charCodeAt(i);
            if (charCode >= 97 && charCode <= 122) {
                // 'a' to 'z'
                const index = charCode - 97; // 'a' 的 ASCII 是 97
                positions[index].push(i);
            }
        }

        let minDistance = 100005; // 初始化为一个大数

        // 遍历所有字母
        for (let j = 0; j < 26; j++) {
            const charPositions = positions[j];
            const count = charPositions.length;

            // 如果字符出现次数少于2次，跳过
            if (count < 2) continue;

            // 计算首尾位置的距离
            const first = charPositions[0];
            const last = charPositions[count - 1];

            // 首尾位置之间的字符数（不包括首尾）
            minDistance = Math.min(minDistance, last - first - 1);

            // 整个字符串长度减去首尾位置之间的长度（包括首尾）
            minDistance = Math.min(
                minDistance,
                str.length - (last - first + 1)
            );

            // 计算相邻位置的距离
            for (let k = 1; k < count; k++) {
                const prev = charPositions[k - 1];
                const curr = charPositions[k];
                minDistance = Math.min(minDistance, curr - prev - 1);
            }
        }

        // 如果没有找到重复字符，返回 -1
        return minDistance === 100005 ? -1 : minDistance;
    }
```

#### 75.  翻之
```javascript
// 读取 n 和 m
    const [n, m] = (await readline()).split(" ").map(Number);

    // 读取 n 个字符串
    const str = [];
    for (let i = 0; i < n; i++) {
        str.push(await readline());
    }

    // 统计列字符串的出现频率
    const colFrequency = new Map();
    // 遍历每一列
    for (let i = 0; i < m; i++) {
        let colStr = "";

        // 遍历每一行，获取当前列的字符
        for (let j = 0; j < n; j++) {
            colStr += str[j][i];
        }

        // 更新频率计数
        colFrequency.set(colStr, (colFrequency.get(colStr) || 0) + 1);
    }
    // 找出最高频率
    let maxFrequency = 0;
    for (const count of colFrequency.values()) {
        if (count > maxFrequency) {
            maxFrequency = count;
        }
    }

    console.log(maxFrequency);
```

#### 76.  购物单
```javascript
let base = 10; //题目中最小间隔10
    let [sum, num] =(await readline()).split(" ");
    sum = sum / base;
    let list = {};
    for (let i = 0; i < num; i++) {
        let [a, b, c] = (await readline()).split(" ").map(Number);
        if (c) {
            //lines[2]如果上面没有Number转换的话输入的是字符串0，if('0')为true
            list[c] = list[c] || [];
            list[c][1] = list[c][1] || [];
            list[c][1].push(a / base, (a / base) * b);
        } else {
            list[i + 1] = list[i + 1] || [];
            list[i + 1][0] = [a / base, (a / base) * b];
        }
    }
    list = [...Object.values(list)];
    buy(list);
    function buy(m) {
        let len = m.length;
        let dp = Array.from({ length: len }, (e) => new Array(sum + 1).fill(0));
        dp[-1] = new Array(sum + 1).fill(0); //加一行-1用于第一行初始化中的边界i-1的判断
        for (let i = 0; i < len; i++) {
            for (let j = 1; j <= sum; j++) {
                if (j < m[i][0][0]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    //一共只有0，1,2个配件3种情况，手写3种判断，w、v分别代表重量和价值
                    let w1, w2, v1, v2;
                    m[i][1] &&
                        ((w1 = m[i][1][0]),
                        (v1 = m[i][1][1]),
                        (w2 = m[i][1][2]),
                        (v2 = m[i][1][3]));
                    dp[i][j] = Math.max(
                        dp[i - 1][j],
                        dp[i - 1][j - m[i][0][0]] + m[i][0][1]
                    );
                    //+undefined为NaN，NaN做判断都是false
                    j >= m[i][0][0] + w1 &&
                        (dp[i][j] = Math.max(
                            dp[i][j],
                            dp[i - 1][j - m[i][0][0] - w1] + m[i][0][1] + v1
                        ));
                    //此处w2也用dp[i][j](上面w1比较后的结果)作比较，即v1,v2也在此处做了比较了
                    j >= m[i][0][0] + w2 &&
                        (dp[i][j] = Math.max(
                            dp[i][j],
                            dp[i - 1][j - m[i][0][0] - w2] + m[i][0][1] + v2
                        ));
                    j >= m[i][0][0] + w1 + w2 &&
                        (dp[i][j] = Math.max(
                            dp[i][j],
                            dp[i - 1][j - m[i][0][0] - w1 - w2] +
                                m[i][0][1] +
                                v1 +
                                v2
                        ));
                }
            }
        }
        console.log(dp[len - 1][sum] * base);
    }
```

#### 77.合唱队
```javascript
 while ((line = await readline())) {
        let num = parseInt(line);
        const arr = (await readline())
            .split(" ")
            .slice(0, num)
            .map((n) => parseInt(n));
        let dp1 = handle(arr);
        let dp2 = handle(arr.reverse()).reverse();
        let max = 0;
        for (let i = 0; i < dp1.length; i++) {
            max = Math.max(max, dp1[i] + dp2[i] - 1);
        }
        //     console.log(dp1.join(' '))
        //     console.log(dp2.join(' '))
        console.log(arr.length - max);
    }
    function handle(arr) {
        const dp = [];
        for (let i = 0; i < arr.length; i++) {
            dp[i] = 1;
            for (let j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        return dp;
    }
```

#### 78.合唱队
```javascript
 while ((line = await readline())) {
        let num = parseInt(line);
        const arr = (await readline())
            .split(" ")
            .slice(0, num)
            .map((n) => parseInt(n));
        let dp1 = handle(arr);
        let dp2 = handle(arr.reverse()).reverse();
        let max = 0;
        for (let i = 0; i < dp1.length; i++) {
            max = Math.max(max, dp1[i] + dp2[i] - 1);
        }
        //     console.log(dp1.join(' '))
        //     console.log(dp2.join(' '))
        console.log(arr.length - max);
    }
    function handle(arr) {
        const dp = [];
        for (let i = 0; i < arr.length; i++) {
            dp[i] = 1;
            for (let j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        return dp;
    }
```

#### 79.喜欢切数组的红
```javascript
 const T = 1; // 测试用例数量固定为1
    for (let t = 0; t < T; t++) {
        const n = parseInt(await readline());
        const data = (await readline()).split(" ").map(Number);

        // 创建数组，索引从1开始
        const a = [0];
        for (let i = 1; i <= n; i++) {
            a[i] = data[i - 1];
        }

        solve(n, a);
    }

    function solve(n, a) {
        // 前缀和数组
        const sum = [0];
        // 前缀大于0的元素个数
        const ne = [0];

        // 计算前缀和和前缀大于0的元素个数
        for (let i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + a[i];
            ne[i] = ne[i - 1] + (a[i] > 0 ? 1 : 0);
        }

        // 如果总和不能被3整除，输出0
        if (sum[n] % 3 !== 0) {
            console.log(0);
            return;
        }

        // 目标值：总和的三分之一
        const target = sum[n] / 3;

        // nt[i]: 从i开始向右第一个大于0的位置
        const nt = new Array(n + 2);
        // f[i]: 从i到n的和等于target的位置个数（后缀和）
        const f = new Array(n + 2).fill(0);

        // 初始化nt数组
        nt[n + 1] = n + 1;
        for (let i = n; i >= 1; i--) {
            nt[i] = a[i] > 0 ? i : nt[i + 1];
        }

        // 计算f数组（后缀和）
        for (let i = n; i >= 1; i--) {
            // 计算从i到n的和
            const subSum = sum[n] - sum[i - 1];
            // 检查从i到n是否有大于0的元素
            const hasPositive = ne[n] - ne[i - 1] > 0;

            f[i] = f[i + 1] + (hasPositive && subSum === target ? 1 : 0);
        }

        let ans = 0;

        // 遍历所有可能的分割点
        for (let i = 1; i <= n; i++) {
            // 检查前i个元素是否有大于0的元素
            if (ne[i] === 0) continue;

            // 检查前i个元素的和是否等于target
            if (sum[i] !== target) continue;

            // 找到下一个大于0的位置
            const r = nt[i + 1];

            // 确保有足够的空间分割三个子数组
            if (r < n) {
                ans += f[r + 1];
            }
        }

        console.log(ans);
    }
```

#### 80.气球谜题
```javascript
 // 定义一个大数作为初始值
    const INF = Number.MAX_SAFE_INTEGER;
    const n = parseInt(await readline());
    const s = (await readline()).trim();
    const t = [0, ...(await readline()).split(" ").map(Number)];

    // 初始化前缀和数组
    const pre = Array.from({ length: n + 1 }, () => [0, 0, 0]);
    // 构建前缀和数组
    for (let i = 1; i <= n; i++) {
        pre[i][0] = pre[i - 1][0];
        pre[i][1] = pre[i - 1][1];
        pre[i][2] = pre[i - 1][2];

        if (s[i - 1] === "0") {
            pre[i][1] += t[i];
            pre[i][2] += t[i];
        } else if (s[i - 1] === "1") {
            pre[i][0] += t[i];
            pre[i][2] += t[i];
        } else {
            pre[i][0] += t[i];
            pre[i][1] += t[i];
        }
    }
    let ans = INF;

    // 所有可能的排列：0-1-2 的所有组合
    const permutations = [
        [0, 1, 2],
        [0, 2, 1],
        [1, 0, 2],
        [1, 2, 0],
        [2, 0, 1],
        [2, 1, 0],
    ];
    // 遍历所有排列
    for (const perm of permutations) {
        const mn = new Array(n + 1).fill(0);

        // 构建 mn 数组
        if (n >= 1) {
            mn[1] = pre[1][perm[0]] - pre[1][perm[1]];

            for (let i = 2; i <= n; i++) {
                const diff = pre[i][perm[0]] - pre[i][perm[1]];
                mn[i] = Math.min(mn[i - 1], diff);
            }
        }

        // 计算当前排列的最优解
        for (let i = n + 1; i >= 1; i--) {
            const val =
                pre[n][perm[2]] -
                (i >= 1 ? pre[i - 1][perm[2]] : 0) +
                (i >= 1 ? pre[i - 1][perm[1]] : 0) +
                (i >= 1 ? mn[i - 1] : 0);

            ans = Math.min(ans, val);
        }
    }

    console.log(ans);
```
#### 81.小红的二分图构造
```javascript
const n = parseInt(await readline());
    const d = [0]; // 索引0不使用，从1开始
    let sum = 0;

    // 读取度数并计算总和
    const degrees = (await readline()).split(" ").map(Number);
    for (let i = 1; i <= n; i++) {
        d[i] = degrees[i - 1];
        sum += d[i];
    }
    // 如果总度数为奇数，则无法分割
    if (sum % 2 !== 0) {
        console.log(-1);
        rl.close();
        return;
    }

    const target = sum / 2;
    const dp = Array.from({ length: n + 1 }, () =>
        Array(target + 1).fill(-Infinity)
    );
    // 初始化DP
    dp[0][0] = 0;

    // 动态规划填表
    for (let i = 1; i <= n; i++) {
        for (let j = 0; j <= target; j++) {
            // 不选当前节点
            dp[i][j] = dp[i - 1][j];

            // 选当前节点（如果可以）
            if (j >= d[i] && dp[i - 1][j - d[i]] !== -Infinity) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - d[i]] + 1);
            }
        }
    }
    // 如果无法达成目标
    if (dp[n][target] <= 0) {
        console.log(-1);
        rl.close();
        return;
    }

    // 回溯找出分组
    const v1 = []; // 集合A
    const v2 = []; // 集合B
    let ni = n;
    let nj = target;

    while (ni > 0) {
        if (dp[ni][nj] === dp[ni - 1][nj]) {
            // 没选当前节点，分到集合B
            v2.push(ni);
            ni--;
        } else {
            // 选了当前节点，分到集合A
            v1.push(ni);
            nj -= d[ni];
            ni--;
        }
    }

    // 输出边的数量
    console.log(target);

    // 构建连接方案
    let i = 0;
    let j = 0;

    while (i < v1.length && j < v2.length) {
        const node1 = v1[i];
        const node2 = v2[j];

        // 输出边
        console.log(`${node1} ${node2}`);

        // 减少度数
        d[node1]--;
        d[node2]--;

        // 如果节点度数为零，移动到下一个节点
        if (d[node1] === 0) i++;
        if (d[node2] === 0) j++;
    }
```

#### 82.小红的双生串
```javascript
const s = await readline(); // 获取用户输入
    const cnt = new Array(200).fill(0); // 创建计数数组（200个元素）
    let maxn = -114514; // 前半部分最大频率初始值

    // 统计前半部分字符频率
    for (let i = 0; i < Math.floor(s.length / 2); i++) {
        const charCode = s.charCodeAt(i);
        cnt[charCode]++;
    }

    // 找出前半部分最大频率（只考虑小写字母 a-z）
    for (let i = 97; i <= 122; i++) {
        if (cnt[i] > maxn) maxn = cnt[i];
    }
    let maxn2 = -114514; // 后半部分最大频率初始值
    cnt.fill(0); // 清空计数数组

    // 统计后半部分字符频率
    for (let i = Math.floor(s.length / 2); i < s.length; i++) {
        const charCode = s.charCodeAt(i);
        cnt[charCode]++;
    }

    // 找出后半部分最大频率（只考虑小写字母 a-z）
    for (let i = 97; i <= 122; i++) {
        if (cnt[i] > maxn2) maxn2 = cnt[i];
    }
    // 计算并输出结果
    const result = s.length - (maxn + maxn2);
    console.log(`${result}`);
```

#### 83.迷宫问题
```javascript
 const [X, Y] =(await readline())
        .split(" ")
        .map((x) => parseInt(x));

    // 使用队列来实现 bfs，将下一步所有可能到达的位置都加入到队列中，完成之后出队当前元素
    // 再将下一个坐标所有可能到达的位置入队，即可
    const map = [];

    while ((line =await readline())) {
        map.push(line.split(" ").map((x) => parseInt(x)));
    }

    // 起点为 (0, 0)
    // 创建队列并将起点坐标加入到队首
    const queue = [[0, 0]];

    // 将所到达的点的父节点记录下来
    const reachedPointMap = new Map();
    // 将第一个结点加入进去
    reachedPointMap.set(`0,0`, `0,0`);

    // 如果当前坐标符合要求，则将其放入队列中
    const reachPoint = ([cx, cy], [fx, fy]) => {
        //     要检查的内容有
        //     1. 是否是数组边界
        //     2. 是否是墙壁
        //     3. 是否已到达过
        //     维护一个集合，当一个点满足条件时，将该点以字符串形式加入到集合中，此后每次需要
        //     判断是否已到达过该点，只需在集合中查找是否存在该点的字符串形式即可
        if (
            cx >= map.length ||
            cx < 0 ||
            cy >= map[0].length ||
            cy < 0 ||
            map[cx][cy] !== 0 ||
            reachedPointMap.has(`${cx},${cy}`)
        ) {
            return;
        }
        //     若该点满足条件则将其加入到队列
        queue.push([cx, cy]);
        reachedPointMap.set(`${cx},${cy}`, `${fx},${fy}`);
    };

    while (queue.length > 0) {
        //     将当前队首元素出队
        //     查看当前队首元素的下一个可到达的点，将其加入到队尾
        //     取得队首点坐标，
        const [curx, cury] = queue.shift();
        //     判断是否为终点，是终点则break
        if (curx + 1 === X && cury + 1 === Y) {
            break;
        }
        //     不是终点：
        //     将该点接下来可到达的位置加入到队列中 顺序为右下左上
        //     依次找到对应的坐标，调用reachPoint函数
        //     继续循环
        else {
            reachPoint([curx + 1, cury], [curx, cury]);
            reachPoint([curx, cury + 1], [curx, cury]);
            reachPoint([curx - 1, cury], [curx, cury]);
            reachPoint([curx, cury - 1], [curx, cury]);
        }
    }

    let tmpx = X - 1,
        tmpy = Y - 1;

    const pathStack = [[tmpx, tmpy]];

    // 当没有到达起点时，寻找当前点的父节点入栈，找到起点时结束
    while (tmpx !== "0" || tmpy !== "0") {
        const [fx, fy] = reachedPointMap.get(`${tmpx},${tmpy}`).split(",");
        pathStack.unshift([fx, fy]);
        (tmpx = fx), (tmpy = fy);
    }

    pathStack.forEach(([x, y]) => {
        console.log(`(${x},${y})`);
    });
```

#### 84. 剪纸游戏
```javascript
class Dot {
    constructor(i, j) {
        this.i = i;
        this.j = j;
    }
}

function answer(mat, i, j, col, row) {
    let maxi = i,
        mini = i,
        minj = j,
        maxj = j;
    let cnt = 1; // 计算小方格的个数
    const queue = [new Dot(i, j)];
    const dx = [0, 1, 0, -1];
    const dy = [1, 0, -1, 0];

    // 标记当前位置为已访问
    mat[i][j] = "*";

    while (queue.length > 0) {
        const temp = queue.shift();

        for (let k = 0; k < 4; k++) {
            const tempX = temp.i + dx[k];
            const tempY = temp.j + dy[k];

            // 检查边界和是否可访问
            if (
                tempX >= 0 &&
                tempX < col &&
                tempY >= 0 &&
                tempY < row &&
                mat[tempX][tempY] === "."
            ) {
                // 标记为已访问
                mat[tempX][tempY] = "*";
                cnt++;
                queue.push(new Dot(tempX, tempY));

                // 更新边界
                if (tempX < mini) mini = tempX;
                if (tempX > maxi) maxi = tempX;
                if (tempY < minj) minj = tempY;
                if (tempY > maxj) maxj = tempY;
            }
        }
    }

    const width = maxi - mini + 1;
    const length = maxj - minj + 1;

    // 检查连通区域是否为矩形
    return cnt === width * length;
}

void (async function () {
    // 读取行列数
    const [col, row] = (await readline(rl, "")).split(" ").map(Number);

    // 读取网格数据
    const mat = [];
    for (let i = 0; i < col; i++) {
        const line = await readline(rl, "");
        mat.push(line.trim().split(""));
    }

    let cnt = 0;
    // 遍历网格寻找连通区域
    for (let i = 0; i < col; i++) {
        for (let j = 0; j < row; j++) {
            if (mat[i][j] === ".") {
                const isRect = answer(mat, i, j, col, row);
                if (isRect) cnt++;
            }
        }
    }

    console.log(cnt);
```

#### 85. 挡住洪水
```javascript
 // Write your code here
    // 读取网格尺寸
    const [n, m] = (await readline("")).split(" ").map(Number);

    // 读取网格数据
    const grid = [];
    for (let i = 0; i < n; i++) {
        const line = await readline("");
        // 将字符串转换为字符数组以便修改
        grid.push(line.split(""));
    }
    // 定义方向数组：右、左、下、上
    const dx = [0, 0, 1, -1];
    const dy = [1, -1, 0, 0];
    // BFS 函数：淹没与边界相连的 '0' 区域
    function bfs(startX, startY) {
        // 如果不是 '0'，直接返回
        if (grid[startX][startY] !== '0') return;

        const queue = [[startX, startY]];
        grid[startX][startY] = '#';

        while (queue.length > 0) {
            const [x, y] = queue.shift();

            // 检查四个方向
            for (let i = 0; i < 4; i++) {
                const nx = x + dx[i];
                const ny = y + dy[i];

                // 检查边界和单元格值
                if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] === '0') {
                    grid[nx][ny] = '#';
                    queue.push([nx, ny]);
                }
            }
        }
    }

    // 1. 从边界开始淹没不安全的 '0' 区域

    // 淹没顶部和底部边界
    for (let j = 0; j < m; j++) {
        // 顶部边界
        if (grid[0][j] === '0') bfs(0, j);
        // 底部边界（如果有多行）
        if (n > 1 && grid[n - 1][j] === '0') bfs(n - 1, j);
    }

    // 淹没左侧和右侧边界
    for (let i = 1; i < n - 1; i++) {
        // 左侧边界
        if (grid[i][0] === '0') bfs(i, 0);
        // 右侧边界（如果有多列）
        if (m > 1 && grid[i][m - 1] === '0') bfs(i, m - 1);
    }

    // 2. 统计安全的 '0' 单元格数量
    let safeCells = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (grid[i][j] === '0') {
                safeCells++;
            }
        }
    }

    console.log(safeCells);
```
#### 86.没挡住洪水
```javascript
 const n = parseInt(await readline());
    const map = [];

    // 读取地图数据
    for (let i = 0; i < n; i++) {
        const line = await readline();
        // 将字符串转换为字符数组以便修改
        map.push(line.split(""));
    }

    // 定义四个方向：下、右、上、左
    const directions = [
        [1, 0],
        [0, 1],
        [-1, 0],
        [0, -1],
    ];
    // BFS 函数：检测岛屿是否会被完全淹没
    function bfs(startX, startY) {
        const queue = [[startX, startY]];
        // 标记已访问
        map[startX][startY] = "*";
        let allBesideWater = true;

        while (queue.length > 0) {
            const [x, y] = queue.shift();
            let besideWater = false;

            // 检查四个方向
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;

                // 检查边界
                if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
                    // 边界外视为水域
                    besideWater = true;
                    continue;
                }

                // 检查是否邻水
                if (map[nx][ny] === ".") {
                    besideWater = true;
                }
                // 检查是否相邻岛屿且未访问
                else if (map[nx][ny] === "#") {
                    map[nx][ny] = "*";
                    queue.push([nx, ny]);
                }
            }

            // 如果当前陆地有任何一边不邻水，整个岛屿不会被完全淹没
            if (!besideWater) {
                allBesideWater = false;
            }
        }

        // 返回岛屿是否会被完全淹没
        return allBesideWater ? 1 : 0;
    }
    let count = 0;

    // 遍历地图检测岛屿
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (map[i][j] === "#") {
                count += bfs(i, j);
            }
        }
    }

    console.log(count);
```
#### 87.迷宫
```javascript
 // 读取网格尺寸
    const [n, m] = (await readline()).split(" ").map(Number);

    // 初始化网格
    const grid = [];
    let start_r = -1,
        start_c = -1;
    let end_r = -1,
        end_c = -1;
    // 读取网格数据并记录起点和终点
    for (let i = 0; i < n; i++) {
        const line = await readline();
        grid.push(line);

        // 查找起点和终点
        for (let j = 0; j < m; j++) {
            if (grid[i][j] === "S") {
                start_r = i;
                start_c = j;
            } else if (grid[i][j] === "E") {
                end_r = i;
                end_c = j;
            }
        }
    }

    // 定义方向数组：上、下、左、右
    const dr = [-1, 1, 0, 0];
    const dc = [0, 0, -1, 1];
    // BFS 函数：返回访问标记数组
    function bfs(start_r, start_c) {
        // 创建访问标记数组
        const visited = Array(n)
            .fill()
            .map(() => Array(m).fill(false));

        // 如果起点无效，直接返回
        if (start_r === -1) return visited;

        const queue = [[start_r, start_c]];
        visited[start_r][start_c] = true;

        while (queue.length > 0) {
            const [r, c] = queue.shift();

            // 检查四个方向
            for (let i = 0; i < 4; i++) {
                const nr = r + dr[i];
                const nc = c + dc[i];

                // 检查边界和障碍物
                if (
                    nr >= 0 &&
                    nr < n &&
                    nc >= 0 &&
                    nc < m &&
                    grid[nr][nc] !== "#" &&
                    !visited[nr][nc]
                ) {
                    visited[nr][nc] = true;
                    queue.push([nr, nc]);
                }
            }
        }

        return visited;
    }
    // 从起点进行BFS
    const visited_s = bfs(start_r, start_c);

    // 如果起点可以直接到达终点
    if (visited_s[end_r] && visited_s[end_r][end_c]) {
        console.log("YES");
        rl.close();
        return;
    }

    // 从终点进行BFS
    const visited_e = bfs(end_r, end_c);

    // 记录起点可达的行和列
    const row_has_s = Array(n).fill(false);
    const col_has_s = Array(m).fill(false);

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (visited_s[i][j]) {
                row_has_s[i] = true;
                col_has_s[j] = true;
            }
        }
    }
    // 检查终点可达的点是否在起点激光的覆盖范围内
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            // 如果这个点可以到达终点
            if (visited_e[i] && visited_e[i][j]) {
                let can_be_reached = false;

                // 检查相邻行
                for (let dr = -1; dr <= 1; dr++) {
                    const nr = i + dr;
                    if (nr >= 0 && nr < n && row_has_s[nr]) {
                        can_be_reached = true;
                        break;
                    }
                }
                if (can_be_reached) {
                    console.log("YES");
                    rl.close();
                    return;
                }

                // 检查相邻列
                for (let dc = -1; dc <= 1; dc++) {
                    const nc = j + dc;
                    if (nc >= 0 && nc < m && col_has_s[nc]) {
                        can_be_reached = true;
                        break;
                    }
                }
                if (can_be_reached) {
                    console.log("YES");
                    return;
                }
            }
        }
    }
    // 没有找到路径
  console.log("NO");
```
#### 88.走一个大整数迷宫
```javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;
class State {
    constructor(x, y, rem) {
        this.x = x;
        this.y = y;
        this.rem = rem;
    }
}
void async function () {
    // 读取输入
    const [n, m, p] = (await readline()).split(' ').map(Number);

    // 读取矩阵a
    const a = [];
    for (let i = 0; i < n; i++) {
        const row = (await readline()).split(' ').map(Number);
        a.push(row);
    }
    // 读取矩阵b（消耗输入但不使用）
    const b = [];
    for (let i = 0; i < n; i++) {
        await readline();
    }

    // 特殊情况处理
    if (p === 1) {
        console.log(-1);
        rl.close();
        return;
    }
    const mod = p - 1;

    // 创建三维距离数组（初始化为-1表示未访问）
    const dist = Array(n).fill().map(() =>
        Array(m).fill().map(() =>
            Array(mod).fill(-1)
        )
    );

    // 初始化队列
    const queue = [];
    // 计算起点余数
    const startRem = ((a[0][0] % mod) + mod) % mod;

    // 设置起点状态
    dist[0][0][startRem] = 0;
    queue.push(new State(0, 0, startRem));

    // 定义方向数组
    const dx = [0, 0, 1, -1];
    const dy = [1, -1, 0, 0];
    // BFS主循环
    while (queue.length > 0) {
        const curr = queue.shift();
        const t = dist[curr.x][curr.y][curr.rem];

        // 检查是否到达终点且余数为0
        if (curr.x === n - 1 && curr.y === m - 1 && curr.rem === 0) {
            console.log(t);
            rl.close();
            return;
        }

        // 尝试四个方向
        for (let i = 0; i < 4; i++) {
            const nx = curr.x + dx[i];
            const ny = curr.y + dy[i];

            // 检查边界
            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                // 计算新余数（确保为正）
                let nextRem = (curr.rem + a[nx][ny]) % mod;
                if (nextRem < 0) nextRem += mod;

                // 检查是否访问过
                if (dist[nx][ny][nextRem] === -1) {
                    // 记录距离并入队
                    dist[nx][ny][nextRem] = t + 1;
                    queue.push(new State(nx, ny, nextRem));
                }
            }
        }
    }

    // 如果遍历结束未找到路径
    console.log(-1);

}()
```
#### 89.  时津风的资源收集
```javascript
// 计算十位和个位的调整代价
function tensCost(r) {
    // r >= 0
    const b1 = Math.floor(r / 10);
    const rem = r % 10;

    // 方案1：向下调整
    const cost1 = b1 + rem;

    // 方案2：向上调整
    let cost2 = b1;
    if (rem !== 0) {
        cost2 += 1 + (10 - rem);
    }

    return Math.min(cost1, cost2);
}
// 计算从0调整到d的代价（使用100、10、1三种步长）
function costDiff(d) {
    // d >= 0
    const a0 = Math.floor(d / 100);
    const r0 = Math.abs(d - 100 * a0);
    let ans = a0 + tensCost(r0);

    const a1 = a0 + 1;
    const r1 = Math.abs(100 * a1 - d);
    ans = Math.min(ans, a1 + tensCost(r1));

    return ans;
}
// 计算从10调整到x的最小代价
function costTo(x) {
    // 直接调整方案
    const d1 = x - 10;
    const directCost = costDiff(Math.abs(d1));

    // 绕道300方案
    const d2 = 300 - x;
    const via300Cost = 1 + costDiff(d2);

    return Math.min(directCost, via300Cost);
}

void (async function () {
    // 读取测试用例数量
    const t = parseInt(await readline());

    // 处理每个测试用例
    for (let i = 0; i < t; i++) {
        const values = (await readline()).split(' ').map(Number);
        const [x1, x2, x3, x4] = values;

        // 计算总代价
        let totalCost = 0;
        totalCost += costTo(x1);
        totalCost += costTo(x2);
        totalCost += costTo(x3);
        totalCost += costTo(x4);

        console.log(totalCost);
    }
})();
```

#### 90.输出单向链表中倒数第k个结点
```javascript
void (async function () {
    while (true) {
        try {
            // 读取第一行：数组长度 l
            const l = parseInt(await readline());

            // 读取第二行：数组元素（空格分隔）
            const sLine = await readline();
            const s = sLine.split(" ");

            // 读取第三行：索引 k
            const k = parseInt(await readline());

            // 处理并输出结果
            if (k === 0) {
                console.log(0);
            } else {
                // 注意：Python 代码中 s[l-k] 使用的是从1开始的索引
                // JavaScript 数组索引从0开始，所以需要调整
                const index = l - k;
                if (index >= 0 && index < s.length) {
                    console.log(s[index]);
                } else {
                    console.log("Invalid index");
                }
            }
        } catch (error) {
            // 输入结束时退出循环
            break;
        }
    }
})();
```

#### 91.小红的01子序列构造（easy）
```javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
    // 读取输入数据
    const [n, k] = (await readline()).split(" ").map(BigInt);
    const s = await readline();

    // 如果k为0，特殊处理（空子串）
    if (k === 0n) {
        console.log("1 1");
        rl.close();
        return;
    }
    // 初始化指针和计数器
    let l = 0; // 左指针
    let r = 0; // 右指针
    let cnt0 = 0; // 当前窗口中的0的数量
    let cnt1 = 0; // 当前窗口中的1的数量
    let num = 0n; // 当前01对的数量（使用BigInt避免溢出）

    // 初始化第一个字符的计数
    if (s[0] === "0") cnt0 = 1;
    if (s[0] === "1") cnt1 = 1;
    // 滑动窗口算法
    while (l < n && r < n) {
        // 找到恰好包含k个01对的子串
        if (num === k) {
            console.log(`${l + 1} ${r + 1}`);
            rl.close();
            return;
        }
        if (num < k) {
            // 向右扩展窗口
            r++;
            if (r >= Number(n)) break; // 防止越界

            if (s[r] === "0") {
                cnt0++;
            } else {
                // 遇到1时，增加前面所有0的数量
                num += BigInt(cnt0);
                cnt1++;
            }
        } else {
            // 向左收缩窗口
            if (s[l] === "0") {
                // 移除0时，减少后面1的数量
                num -= BigInt(cnt1);
                cnt0--;
            } else {
                cnt1--;
            }
            l++;
        }
    }
    // 检查退出循环时是否满足条件
    if (num === k) {
        console.log(`${l + 1} ${r + 1}`);
    } else {
        console.log(-1);
    }

    rl.close();
})();

```
#### 92.【模板】滑动窗口(滑动窗口最大值)
```javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void async function () {
    // 读取输入数据
    const [n, k] = (await readline()).split(' ').map(Number);
    const a = (await readline()).split(' ').map(Number);

    // 初始化双端队列（使用数组模拟）
    const q = []; // 存储数组下标，保持对应值的单调递减
    const result = []; // 存储每个窗口的最大值
    // 处理滑动窗口
    for (let i = 0; i < n; i++) {
        // 移除所有小于当前元素的队尾下标，保持单调性
        while (q.length > 0 && a[q[q.length - 1]] <= a[i]) {
            q.pop();
        }

        // 将当前元素下标加入队尾
        q.push(i);
        // 移除已经滑出窗口的队首下标
        if (q[0] <= i - k) {
            q.shift();
        }

        // 当窗口形成后，记录最大值
        if (i >= k - 1) {
            result.push(a[q[0]]);
        }
    }
    // 输出结果
    console.log(result.join(' '));
    rl.close();
}()

```
#### 93.可匹配子段计数(滑动窗口匹配计数)
```javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
    // 读取测试用例数量
    const t = parseInt(await readline());

    // 处理每个测试用例
    for (let testCase = 0; testCase < t; testCase++) {
        // 读取输入数据
        const [n, m, k] = (await readline()).split(" ").map(Number);
        const a = (await readline()).split(" ").map(Number);
        const b = (await readline()).split(" ").map(Number);

        // 构建数组 b 的频次映射
        const mapB = new Map();
        for (const num of b) {
            mapB.set(num, (mapB.get(num) || 0) + 1);
        }
        // 初始化当前窗口的频次映射
        const mapA = new Map();
        let currentMatch = 0;
        let ans = 0;

        // 初始化第一个窗口
        for (let i = 0; i < m; i++) {
            const num = a[i];
            mapA.set(num, (mapA.get(num) || 0) + 1);
        }
        // 计算初始匹配数
        for (const [num, countB] of mapB) {
            const countA = mapA.get(num) || 0;
            currentMatch += Math.min(countA, countB);
        }

        // 检查初始窗口是否满足条件
        if (currentMatch >= k) ans++;

        // 滑动窗口
        for (let i = m; i < n; i++) {
            const removeVal = a[i - m]; // 要移除的元素
            const addVal = a[i]; // 要添加的元素
            // 处理移除的元素
            if (mapB.has(removeVal)) {
                const countA = mapA.get(removeVal);
                const countB = mapB.get(removeVal);

                // 如果移除前是有效匹配，减少匹配数
                if (countA <= countB) {
                    currentMatch--;
                }
            }
            // 更新移除元素的频次
            mapA.set(removeVal, mapA.get(removeVal) - 1);
            if (mapA.get(removeVal) === 0) {
                mapA.delete(removeVal);
            }

            // 处理添加的元素
            if (mapB.has(addVal)) {
                const countA = mapA.get(addVal) || 0;
                const countB = mapB.get(addVal);

                // 如果添加后增加有效匹配，增加匹配数
                if (countA < countB) {
                    currentMatch++;
                }
            }
            // 更新添加元素的频次
            mapA.set(addVal, (mapA.get(addVal) || 0) + 1);

            // 检查当前窗口是否满足条件
            if (currentMatch >= k) ans++;
        }

        // 输出结果
        console.log(ans);
    }

    rl.close();
})();
```
#### 94.【模板】双指针(最长无重复子数组)
```javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void async function () {
    // 读取数组长度
    const n = parseInt(await readline());

    // 读取数组元素
    const a = (await readline()).split(' ').map(Number);

    // 初始化变量
    const counts = new Map(); // 存储元素出现次数
    const results = [];       // 存储结果子数组
    let maxLen = 0;          // 最长无重复子数组长度
    let l = 0;               // 滑动窗口左边界
    // 滑动窗口遍历数组
    for (let r = 0; r < n; r++) {
        const num = a[r];

        // 更新当前元素计数
        counts.set(num, (counts.get(num) || 0) + 1);

        // 当出现重复元素时，收缩左边界
        while (counts.get(num) > 1) {
            const leftNum = a[l];
            counts.set(leftNum, counts.get(leftNum) - 1);

            // 如果计数为0，从Map中移除
            if (counts.get(leftNum) === 0) {
                counts.delete(leftNum);
            }

            l++;
        }

        // 计算当前窗口长度
        const currentLen = r - l + 1;

        // 更新最长无重复子数组
        if (currentLen > maxLen) {
            maxLen = currentLen;
            results.length = 0; // 清空之前的结果
            results.push([l + 1, r + 1]); // 1-indexed
        } else if (currentLen === maxLen) {
            results.push([l + 1, r + 1]); // 1-indexed
        }
    }

    // 输出结果
    console.log(results.length);
    for (const [start, end] of results) {
        console.log(`${start} ${end}`);
    }

    rl.close();

}()
```
#### 95.小苯的IDE括号问题（easy）(文本编辑器模拟)
```javascript
//这段代码模拟了一个简单的文本编辑器，支持两种操作：退格键和删除键，并能智能处理括号匹配。
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
    // 读取输入数据
    const [n, m] = (await readline()).split(" ").map(Number);
    const s = await readline();

    // 初始化左右队列
    const leftQ = []; // 存储光标左侧的字符
    const rightQ = []; // 存储光标右侧的字符
    // 查找光标位置并分割字符串
    let cursorPos = -1;
    for (let i = 0; i < n; i++) {
        if (s[i] === "I") {
            cursorPos = i;
            break;
        }
        leftQ.push(s[i]);
    }

    // 将光标右侧的字符加入右侧队列
    for (let i = cursorPos + 1; i < n; i++) {
        rightQ.push(s[i]);
    }

    // 处理操作指令
    for (let i = 0; i < m; i++) {
        const op = await readline();

        if (op === "backspace") {
            // 处理括号匹配删除
            if (
                leftQ.length > 0 &&
                rightQ.length > 0 &&
                leftQ[leftQ.length - 1] === "(" &&
                rightQ[0] === ")"
            ) {
                leftQ.pop();
                rightQ.shift();
            }
            // 普通退格
            else if (leftQ.length > 0) {
                leftQ.pop();
            }
        }
        // 删除操作
        else if (op === "delete") {
            if (rightQ.length > 0) {
                rightQ.shift();
            }
        }
    }

    // 构建最终结果
    const result = leftQ.join("") + "I" + rightQ.join("");
    console.log(result);

    rl.close();
})();

```
#### 96.游游的最长稳定子数组(最长连续子数组)
```javascript
//这段代码使用滑动窗口算法找到数组中最长的连续子数组，其中相邻元素的差值不超过1
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
    // 读取数组长度
    const n = parseInt(await readline());
    // 读取数组元素
    const a = (await readline()).split(" ").map(Number);
    // 初始化变量
    let left = -1; // 前一个元素值
    let indexLeft = 0; // 当前连续子数组的起始索引
    let maxLength = 0; // 最长连续子数组长度

    // 处理每个元素
    for (let i = 0; i < n; i++) {
        const elem = a[i];
        // console.log(elem)
        // 检查是否满足连续条件
        if (left === -1 || Math.abs(left - elem) <= 1) {
            // 更新最大长度
            maxLength = Math.max(maxLength, i - indexLeft + 1);
        } else {
            // 不满足条件，重置起始索引
            indexLeft = i;
        }
        // 更新前一个元素值
        left = elem;
    }

    // 输出结果
    console.log(maxLength);
    rl.close();
})();
```
#### 97.相差不超过k的最多数
```javascript
//这段代码使用排序和滑动窗口算法找到数组中最长的连续子数组，其中最大值和最小值的差值不超过给定的 k。
void async function () {
    // 读取输入数据
    const [n, k] = (await readline()).split(' ').map(Number);
    const a = (await readline()).split(' ').map(Number);

    // 对数组进行排序
    a.sort((x, y) => x - y);

    // 初始化指针和结果
    let l = 0;      // 左指针
    let r = 0;      // 右指针
    let ans = 0;    // 最长子数组长度
    // 滑动窗口算法
    while (r < n) {
        // 当窗口内最大值与最小值的差大于 k 时，移动左指针
        if (a[r] - a[l] > k) {
            l++;
        }
        // 更新最大长度
        else {
            ans = Math.max(ans, r - l + 1);
            r++;
        }
    }
    // 输出结果
    console.log(ans);
    rl.close();
}()
```
#### 98.画展布置(最小平方差子数组)
```javascript
void (async function () {
    // 读取输入数据
    const [n, m] = (await readline()).split(" ").map(Number);

    // 创建数组（索引0不使用）
    const a = [0];
    const data = (await readline()).split(" ").map(Number);
    for (let i = 1; i <= n; i++) {
        a[i] = data[i - 1];
    }
    // 对数组进行排序（从第1个元素到第n个元素）
    a.sort((x, y) => x - y);

    // 初始化结果为足够大的值
    let ans = 1000000000000; // 1e12
    // 查找最小平方差值
    for (let i = 1; i <= n - m + 1; i++) {
        const diff = a[i + m - 1] * a[i + m - 1] - a[i] * a[i];
        if (diff < ans) {
            ans = diff;
        }
    }

    // 输出结果
    console.log(ans);
    rl.close();
})();
```
#### 99.？？？(子序列匹配与通配符替换)
```javascript
//这段代码主要解决一个字符串匹配问题：给定两个字符串，其中一个包含通配符 '?'，判断是否可以替换这些通配符使得另一个字符串成为它的子序列。
function solveTestCase(T, testCases) {
    for (let i = 0; i < T; i++) {
        const [sArr, tArr] = testCases[i];

        let p1 = 0; // s的指针
        let p2 = 0; // t的指针

        // 遍历字符串进行匹配
        while (p1 < sArr.length && p2 < tArr.length) {
            if (sArr[p1] === "?") {
                // 将?替换为t中对应字符
                sArr[p1] = tArr[p2];
                p1++;
                p2++;
            } else if (sArr[p1] === tArr[p2]) {
                // 匹配成功，同时移动两个指针
                p1++;
                p2++;
            } else {
                // 不匹配，跳过s的当前字符
                p1++;
            }
        }

        // 处理剩余的?字符
        const resultStr = sArr
            .map((char) => (char === "?" ? "a" : char))
            .join("");

        // 判断是否完全匹配
        if (p2 === tArr.length) {
            console.log("YES");
            console.log(resultStr);
        } else {
            console.log("NO");
        }
    }
}
void (async function () {
    // 读取测试用例数量
    const T = parseInt(await readline());
    const testCases = [];

    // 读取每个测试用例
    for (let i = 0; i < T; i++) {
        const s = await readline();
        const t = await readline();
        testCases.push([s.split(''), t.split('')]);
    }
    // 处理所有测试用例
    solveTestCase(T, testCases);
})()
```
#### 100.24点游戏算法
```javascript
//这段代码使用递归算法解决经典的24点游戏问题：给定4个数字，判断是否可以通过加、减、乘、除运算得到24。
void (async function () {
    let sign = false;
    const dp = (arr, res) => {
        //剪枝
        if (res > 24) {
            return;
        }
        //满足条件并剪枝
        if (res === 24) {
            sign = true;
            return;
        }
        if (res < 24) {
            for (let i = 0; i < arr.length; i++) {
                //拷贝下数组，原数组需要多次使用，不能修改
                let newArr = arr.slice();
                //下一次是数组是去掉当前数字的数组
                newArr.splice(i, 1);
                if (res === 0) {
                    //初始化的时候
                    dp(newArr, arr[i]);
                } else {
                    //正常+-*/
                    dp(newArr, res * arr[i]);
                    dp(newArr, res + arr[i]);
                    dp(newArr, res - arr[i]);
                    dp(newArr, res / arr[i]);
                }
            }
        }
    };
    dp((await readline()).split(' ').map(Number), 0);
    console.log(sign);

})();

```
#### 101.迷宫寻路（迷宫路径搜索）
```javascript
//这段代码使用深度优先搜索算法在迷宫中寻找从起点(0,0)到终点(n-1,m-1)的路径
void (async function () {
    // 读取迷宫尺寸
    const [n, m] = (await readline()).split(" ").map(Number);

    // 读取迷宫地图
    const desk = [];
    for (let i = 0; i < n; i++) {
        const line = await readline();
        desk.push(line.split(""));
    }
    // 初始化变量
    let x = 0,
        y = 0; // 当前位置
    const pos = [[0, 0]]; // 路径栈
    const dirs = [
        [1, 0],
        [0, 1],
        [-1, 0],
        [0, -1],
    ]; // 方向：下、右、上、左
    while (true) {
        // 到达终点
        if (x === n - 1 && y === m - 1) {
            console.log("Yes");
            break;
        }

        // 标记当前位置为已访问
        desk[x][y] = "x";

        let moved = false; // 是否成功移动

        // 尝试四个方向
        for (const [dx, dy] of dirs) {
            const nx = x + dx;
            const ny = y + dy;

            // 检查新位置是否有效
            if (
                nx >= 0 &&
                nx < n &&
                ny >= 0 &&
                ny < m &&
                desk[nx][ny] === "."
            ) {
                // 移动到新位置
                x = nx;
                y = ny;
                pos.push([x, y]);
                moved = true;
                break;
            }
        }

        // 如果无法移动，回溯
        if (!moved) {
            if (pos.length === 0) {
                console.log("No");
                break;
            }
            // 回溯到上一个位置
            [x, y] = pos.pop();
        }
    }
})();
```
#### 102.数水坑(水域连通块计数)
```javascript
//这段代码使用深度优先搜索（DFS）算法计算水域（'W'）的连通块数量，考虑8个方向的连通性（包括对角线）
void async function () {
    // 读取地图尺寸
    const [N, M] = (await readline()).split(' ').map(Number);

    // 读取地图数据并初始化访问标记
    const visited = [];
    for (let i = 0; i < N; i++) {
        const row = await readline();
        const visitRow = [];
        for (let j = 0; j < row.length; j++) {
            visitRow.push(row[j] === 'W' ? false : true);
        }
        visited.push(visitRow);
    }
    let output = 0; // 水域连通块计数器

    // 定义8个方向（包括对角线）
    const directions = [
        [-1, 0],  // 上
        [-1, -1], // 左上
        [-1, 1],  // 右上
        [1, 0],   // 下
        [1, -1],  // 左下
        [1, 1],   // 右下
        [0, -1],  // 左
        [0, 1]    // 右
    ];

    // DFS 函数：标记连通的水域
    function dfs(i, j) {
        // 如果已访问或是陆地，直接返回
        if (visited[i][j]) return;

        // 标记为已访问
        visited[i][j] = true;

        // 遍历所有8个方向
        for (const [dx, dy] of directions) {
            const ni = i + dx;
            const nj = j + dy;

            // 检查新位置是否在边界内
            if (ni >= 0 && ni < N && nj >= 0 && nj < M) {
                dfs(ni, nj);
            }
        }
    }

    // 遍历地图，统计水域连通块
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < M; j++) {
            // 如果是未访问的水域
            if (!visited[i][j]) {
                dfs(i, j);
                output++;
            }
        }
    }

    // 输出结果
    console.log(output);
}()
```
#### 103.全排列
```javascript
//这段代码使用深度优先搜索（DFS）算法生成数字 1 到 n 的所有排列（全排列）
 while ((line = await readline())) {
        const n = parseInt(line);

        // 初始化数组和访问标记
        const a = new Array(10).fill(0); // 存储当前排列
        const vis = new Array(10).fill(false); // 标记数字是否已使用
        // DFS 函数生成全排列
        function dfs(dep) {
            // 当深度达到 n+1 时，输出一个完整的排列
            if (dep === n + 1) {
                let line = "";
                for (let i = 1; i < dep; i++) {
                    line += a[i] + " ";
                }
                console.log(line.trim());
                return;
            }

            // 尝试每个未使用的数字
            for (let i = 1; i <= n; i++) {
                if (!vis[i]) {
                    vis[i] = true; // 标记为已使用
                    a[dep] = i; // 存入当前排列
                    dfs(dep + 1); // 递归下一层
                    vis[i] = false; // 回溯，取消标记
                }
            }
        }

        // 从第一层开始生成排列
        dfs(1);
    }

```
#### 104.模意义下最大子序列(最大子集和模值)
```javascript
//这段代码解决一个问题：给定 n 个数字和一个整数 m，找出所有非空子集和中模 m 的最大值。
void (async function () {
    // 读取输入数据
    const [n, m] = (await readline()).split(" ").map(Number);
    const a = (await readline()).split(" ").map(Number);

    let res = 0; // 最大模值

    // 枚举所有非空子集（2^n - 1 种可能）
    for (let i = 1; i < 1 << n; i++) {
        let s = 0; // 当前子集和模 m

        // 计算当前子集的和模 m
        for (let j = 0; j < n; j++) {
            // 检查第 j 位是否被选中
            if (i & (1 << j)) {
                s = (s + a[j]) % m;
            }
        }

        // 更新最大模值
        res = Math.max(res, s);

        // 如果已经达到最大值，提前结束
        if (res === m - 1) break;
    }

    // 输出结果
    console.log(res);
})();

```
#### 105.取数游戏(非相邻格子最大和)
```javascript
//这段代码使用回溯算法解决一个网格问题：在 N×M 的网格中，选择一些不相邻的格子（包括左上、上、右上、左方向），使得它们的和最大。
void async function () {
    // 读取测试用例数量
    const T = parseInt(await readline());

    for (let i = 0; i < T; i++) {
        // 读取网格尺寸
        const [N, M] = (await readline()).split(' ').map(Number);

        // 读取网格数据
        const matrix = [];
        for (let j = 0; j < N; j++) {
            const row = (await readline()).split(' ').map(Number);
            matrix.push(row);
        }

        let ans = 0; // 最大和
        // 检查位置 (y, x) 是否可以放置
        function possible(y, x, posSet) {
            // 检查四个方向：左上、上、右上、左
            const directions = [
                [y - 1, x - 1], // 左上
                [y - 1, x],     // 上
                [y - 1, x + 1], // 右上
                [y, x - 1]      // 左
            ];

            for (const [i, j] of directions) {
                if (i < 0 || j < 0) continue; // 边界检查
                if (posSet.has(`${i},${j}`)) return false; // 冲突检查
            }

            return true;
        }

        // 回溯函数
        function backtracking(row, col, total, posSet) {
            // 更新最大和
            ans = Math.max(ans, total);

            // 遍历所有可能的格子
            for (let i = row; i < N; i++) {
                // 确定起始列：如果是当前行，从当前列开始；否则从0开始
                const startCol = (i === row) ? col : 0;

                for (let j = startCol; j < M; j++) {
                    // 检查是否可以放置
                    if (possible(i, j, posSet)) {
                        const key = `${i},${j}`;
                        posSet.add(key); // 标记位置
                        backtracking(i, j + 1, total + matrix[i][j], posSet);
                        posSet.delete(key); // 回溯
                    }
                }
            }
        }

        // 开始回溯
        backtracking(0, 0, 0, new Set());

        // 输出结果
        console.log(ans);
    }
}()
```
#### 106.小A的线段（easy version）(覆盖方案计数（离散化与状态压缩）)
```javascript
//该算法高效处理了坐标范围大但线段数量有限的情况（m ≤ 20
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;
const MOD = 998244353;
void (async function () {
    // 读取输入数据
    const [n, m] = (await readline()).split(" ").map(Number);
    const segments = [];

    // 读取所有线段
    for (let i = 0; i < m; i++) {
        const [st, ed] = (await readline()).split(" ").map(Number);
        segments.push([st, ed]);
    }

    // 离散化坐标点
    const pointSet = new Set([1, n + 1]);
    for (const [st, ed] of segments) {
        pointSet.add(st);
        pointSet.add(ed + 1);
    }
    const points = Array.from(pointSet).sort((a, b) => a - b);
    const pointIndex = new Map(points.map((p, i) => [p, i]));

    // 创建差分数组
    const diffSize = points.length;

    // 状态压缩：枚举所有线段选择方案
    const totalStates = 1 << m;
    let count = 0;

    // 遍历所有可能的状态
    for (let state = 0; state < totalStates; state++) {
        // 为当前状态创建差分数组
        const diff = new Array(diffSize).fill(0);

        // 应用当前选择的线段
        for (let i = 0; i < m; i++) {
            if (state & (1 << i)) {
                const [st, ed] = segments[i];
                const startIdx = pointIndex.get(st);
                const endIdx = pointIndex.get(ed + 1);
                diff[startIdx]++;
                if (endIdx < diffSize) diff[endIdx]--;
            }
        }

        // 计算前缀和得到各区间覆盖次数
        const coverage = new Array(diffSize).fill(0);
        coverage[0] = diff[0];
        for (let i = 1; i < diffSize; i++) {
            coverage[i] = coverage[i - 1] + diff[i];
        }

        // 检查是否所有区间都被覆盖至少两次
        let valid = true;
        for (let i = 0; i < points.length - 1; i++) {
            const intervalLength = points[i + 1] - points[i];
            if (coverage[i] < 2 && intervalLength > 0) {
                valid = false;
                break;
            }
        }

        if (valid) count = (count + 1) % MOD;
    }

    console.log(count);
})();
```
### 107.名字的漂亮度
```javascript
let num = await readline()
for (let i = 0; i < num; i++) {
    let str = await readline();
    let map =[];
    let res = 0;
    let arr = str.toLowerCase().split("");
    let obj = arr.reduce((pre, next) => {
        if (pre[next]) pre[next]++
        else pre[next] = 1
        return pre
    }, {});
    map = Object.values(obj).map(Number)
    map.sort((a, b) => b - a);
    
    for (let i = 0; i < 26; i++) {
        res += (map[i] || 0) * (26 - i);
    }
    console.log(res);
}

```

### 108.查找两个字符串a,b中的最长公共子串
```javascript
 (async function () {
    const line1 =await readline();
    const line2 =await readline();

    let short = line1.length >= line2.length ? line2 : line1;
    let long = line1.length >= line2.length ? line1 : line2;

    let common = "";
    let i = 0;
    let j = 1;
    while (i < short.length && j < short.length + 1) {
        let temp = short.slice(i, j);
        if (long.indexOf(temp) > -1) {
            common = temp.length > common.length ? temp : common;
            j++;
        } else {
            i++;
            j = i + 1;
        }
    }

    console.log(common);
})();

```

### 109.字符串通配符
```javascript
 void (async function () {
    // Write your code here
    // 转义点号
    const regx = await readline();
    const target = await readline()
    let pattern = regx.replace(/\./g, "\\.");
    // 替换问号（匹配一个字符）
    pattern = pattern.replace(/\?/g, "[0-9A-Za-z]{1}");
    // 替换星号（匹配0个或多个字符）
    pattern = pattern.replace(/\*/g, "[0-9A-Za-z]{0,}");

    // 创建正则表达式（不区分大小写）
    const regex = new RegExp(`^${pattern}$`, "i");
    const result = regex.test(target);

    console.log(result);
})();

```

### 110.计算日期到天数转换
```javascript
 void (async function () {
    // Write your code here
    // 转义点号
    let line=(await readline()).split(' ')
    let year=line[0]
    let month=line[1]
    let day=line[2]
    let sum=0
    for(let i=month -1;i>0;i--){
       sum+=new Date(year,i,0).getDate()
    }
    console.log(sum+Number(day))
})();

```

### 111.公共子串计算
```javascript
void (async function () {
    // Write your code here
    let str1 =await readline()
    let str2 =await readline()

    let max = 0;
    let short;
    let long;
    short = str1.length >= str2.length ? str2 : str1;
    long = str1.length >= str2.length ? str1 : str2;
    for (let i = short.length; i >= 1; i--) {
        for (let j = 0; j + i <= short.length; j++) {
            if (long.includes(short.substr(j, i))) {
                max = Math.max(max, short.substr(j, i).length);
            }
        }
    }
    console.log(max);
})();
```

### 112.字符统计
```javascript
  while ((line = await readline())) {
        let str = line;
        let obj = {};
        let res = "";
        for (let i = 0; i < str.length; i++) {
            if (obj[str[i]]) obj[str[i]]++;
            else obj[str[i]] = 1;
        }
        let arr = Object.entries(obj);


        arr.sort((a, b) => {
            if (a[1] == b[1]) return a[0].charCodeAt() - b[0].charCodeAt();
            else return b[1] - a[1];
        });

        for (item of arr) {
            res += item[0];
        }
        console.log(res);
    }
```