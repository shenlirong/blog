---
title: 知识点
icon: pen-to-square
# sticky: -1
category:
  - 知识点
# permalink: /website/
---

<!-- more -->
::: info
字符串、数据结构、动态规划、排序、深度/广度优先搜索、贪心、双指针
:::

## 排序方法

经典的十大排序算法，它们包括：

1.冒泡排序（Bubble Sort）
2.选择排序（Selection Sort）
3.插入排序（Insertion Sort）
4.希尔排序（Shell Sort）
5.归并排序（Merge Sort）
6.快速排序（Quick Sort）
7.堆排序（Heap Sort）
8.计数排序（Counting Sort）
9.桶排序（Bucket Sort）
10.基数排序（Radix Sort）

## 基本思路
**1.冒泡排序（Bubble Sort）**
思路：重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作重复进行直到没有再需要交换的元素。
时间复杂度：最好情况O(n)（已经有序），最坏和平均O(n²)
空间复杂度：O(1)
稳定性：稳定

**2.选择排序（Selection Sort）**
思路：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
时间复杂度：始终是O(n²)
空间复杂度：O(1)
稳定性：不稳定（例如：[5, 5, 2] 第一个5会和2交换，然后两个5的相对位置就变了）

**3.插入排序（Insertion Sort）**
思路：将待排序的元素插入到已经有序的序列中的适当位置。从第一个元素开始，该元素可以认为已经被排序，取出下一个元素，在已经排序的元素序列中从后向前扫描，找到相应位置并插入。
时间复杂度：最好O(n)（已经有序），最坏和平均O(n²)
空间复杂度：O(1)
稳定性：稳定

**4.希尔排序（Shell Sort）**
思路：插入排序的改进版，也称为缩小增量排序。将待排序的数组按一定增量分组，对每组使用插入排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至1时，整个数组被分成一组，再使用插入排序。
时间复杂度：取决于增量序列，最坏情况O(n²)，好的增量序列可以使得最坏情况为O(n log²n)
空间复杂度：O(1)
稳定性：不稳定

**5.归并排序（Merge Sort）**
思路：采用分治法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。通常使用递归实现。
时间复杂度：O(n log n) 所有情况都是
空间复杂度：O(n) （需要临时数组）
稳定性：稳定

**6.快速排序（Quick Sort）**
思路：通过一次排序将数组分为两部分，左边部分的所有值小于右边部分，然后对两部分递归进行排序。
具体步骤：选取一个基准值（pivot），将小于基准值的元素放在左边，大于基准值的元素放在右边，然后对左右两个子数组重复这个过程。
时间复杂度：平均O(n log n)，最坏O(n²)（当数组已经有序且选第一个为基准）
空间复杂度：O(log n) （递归调用栈）
稳定性：不稳定

**7.堆排序（Heap Sort）**
思路：利用堆这种数据结构。将待排序序列构造成一个大顶堆（升序排序），然后将堆顶元素与末尾元素交换，此时末尾为最大值，然后将剩余n-1个元素重新调整为堆，如此反复。
时间复杂度：O(n log n)
空间复杂度：O(1)
稳定性：不稳定

**8.计数排序（Counting Sort）**
思路：将输入的数据值转化为键存储在额外开辟的数组空间中。要求输入的数据必须是有确定范围的整数。
具体步骤：找出待排序数组中的最大和最小元素，统计每个元素出现的次数，然后根据次数回填到原数组。
时间复杂度：O(n+k)（k为整数的范围）
空间复杂度：O(k)
稳定性：稳定（但实现时要注意从后向前遍历以保证稳定性）

**9.桶排序（Bucket Sort）**
思路：将数组分到有限数量的桶里，每个桶再分别排序（可以使用其他排序方法）。
时间复杂度：平均O(n+k)，最坏O(n²)（当所有元素都在一个桶里）
空间复杂度：O(n+k)
稳定性：稳定（取决于桶内排序的稳定性）

**10.基数排序（Radix Sort）**
思路：按照低位先排序，然后收集；再按照高位排序，然后再收集；以此类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。
时间复杂度：O(n*k)（k为最大数字的位数）
空间复杂度：O(n+k) （k为桶的数量）
稳定性：稳定

### 1. 冒泡排序 (Bubble Sort)
- 思想：通过相邻元素的比较和交换，将较大的元素逐渐“冒泡”到数组的末尾。重复交换相邻逆序元素，每次循环将最大值"冒泡"到末尾。
- 代码：
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j+1]) 
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; // 交换
    }
  }
  return arr;
}
```
- 时间复杂度：
    - 最好：O(n)（已有序时）
    - 平均/最差：O(n²)
- 空间复杂度：O(1)
- 稳定性：✅ 稳定
---

### 2. 选择排序 (Selection Sort)
- 思想：在未排序序列中找最小元素，与未排序首部交换
- 代码：
```javascript
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let minIdx = i;
    for (let j = i+1; j < arr.length; j++) {
      if (arr[j] < arr[minIdx]) minIdx = j;
    }
    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
  }
  return arr;
}
```
- 时间复杂度：O(n²)（始终）
- 空间复杂度：O(1)
- 稳定性：❌ 不稳定（交换可能改变顺序）
---

### 3. 插入排序 (Insertion Sort)
- 思想：将元素插入到前面已排序序列的合适位置
- 代码：
```javascript
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let key = arr[i], j = i-1;
    while (j >= 0 && arr[j] > key) {
      arr[j+1] = arr[j]; // 后移
      j--;
    }
    arr[j+1] = key;
  }
  return arr;
}
```
- 时间复杂度：
    - 最好：O(n)（已有序）
    - 平均/最差：O(n²)
- 空间复杂度：O(1)
- 稳定性：✅ 稳定
---

### 4. 希尔排序 (Shell Sort)
- 思想：带间隔的插入排序（缩小增量排序）
- 时间复杂度：O(n log n) ~ O(n²)（取决于步长序列）
- 空间复杂度：O(1)
- 稳定性：❌ 不稳定
---

### 5. 归并排序 (Merge Sort)
- 思想：分治法（Divide & Conquer），先拆分后合并有序序列
- 代码：
```javascript
function mergeSort(arr) {
  if (arr.length < 2) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  let result = [];
  while (left.length && right.length) {
    left[0] <= right[0] 
      ? result.push(left.shift()) 
      : result.push(right.shift());
  }
  return [...result, ...left, ...right];
}
```
- 时间复杂度：O(n log n)（所有情况）
- 空间复杂度：O(n)（需临时数组）
- 稳定性：✅ 稳定
---

### 6. 快速排序 (Quick Sort)
- 思想：选定基准（pivot），将小于基准的放左边，大于的放右边，递归处理
- 代码：
```javascript
function quickSort(arr) {
  if (arr.length < 2) return arr;
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const middle = arr.filter(x => x === pivot);
  const right = arr.filter(x => x > pivot);
  return [...quickSort(left), ...middle, ...quickSort(right)];
}
```
- 时间复杂度：
    - 最好/平均：O(n log n)
    - 最差：O(n²)（当数组已有序时）
- 空间复杂度：O(log n)（递归栈）
- 稳定性：❌ 不稳定（交换会改变顺序）
---

### 7. 堆排序 (Heap Sort)
- 思想：建立大顶堆，重复将堆顶元素移到末尾并重建堆
- 时间复杂度：O(n log n)（所有情况）
- 空间复杂度：O(1)
- 稳定性：❌ 不稳定
---

### 8. 计数排序 (Counting Sort)
- 思想：统计每个整数出现的次数，再反向填充
- 代码：
```javascript
function countingSort(arr) {
  const max = Math.max(...arr);
  const count = new Array(max+1).fill(0);
  const output = [];

  arr.forEach(num => count[num]++);

  for (let i = 0; i < count.length; i++) {
    while (count[i]--) output.push(i);
  }
  return output;
}
```
- 时间复杂度：O(n + k)（k为数据范围）
- 空间复杂度：O(k)
- 稳定性：✅ 稳定（反向填充可保证）
---

### 9. 桶排序 (Bucket Sort)
- 思想：将数据分到多个桶，对每个桶排序后合并
- 时间复杂度：
    - 平均：O(n + k)
    - 最差：O(n²)（所有元素在一个桶中）
- 空间复杂度：O(n + k)
- 稳定性：✅ 稳定（桶内排序需稳定算法）
---

### 10. 基数排序 (Radix Sort)
- 思想：按位数从低位到高位分别排序（LSD）
- 代码：
```javascript
function radixSort(arr) {
  const max = Math.max(...arr).toString().length;

  for (let i = 0; i < max; i++) {
    const buckets = Array(10).fill().map(() => []);
    arr.forEach(num => {
      const digit = Math.floor(num / Math.pow(10, i)) % 10;
      buckets[digit].push(num);
    });
    arr = [].concat(...buckets);
  }
  return arr;
}
```
- 时间复杂度：O(d(n + k))（d为最大位数，k为进制基数）
- 空间复杂度：O(n + k)
- 稳定性：✅ 稳定
---

### 排序算法对比总结
|排序算法|时间复杂度（平均）|时间复杂度（最坏）|空间复杂度|稳定性|适用场景|
|---|--|---|---|--|--|
|冒泡排序|O(n²)|O(n²)|O(1)|稳定|小规模数据教学|
|选择排序|O(n²)|O(n²)|O(1)|不稳定|仅当交换成本极高时|
|插入排序|O(n²)|O(n²)|O(1)|稳定|小规模或基本有序数据|
|希尔排序|O(n log n) - O(n²)|O(n²)|O(1)|不稳定|中等规模数据|
|归并排序|O(n log n)|O(n log n)|O(n)|稳定|大数据量稳定排序|
|快速排序|O(n log n)|O(n²)|O(log n)|不稳定|通用高效排序（需优化基准）|
|堆排序|O(n log n)|O(n log n)|O(1)|不稳定|对内存限制严格的场景|
|计数排序|O(n + k)|O(n + k)|O(k)|稳定|整数范围较小的数据|
|桶排序|O(n + k)|O(n²)|O(n + k)|稳定|均匀分布的浮点数|
|基数排序|O(d(n + k))|O(d(n + k))|O(n + k)|稳定|多关键字整数（如电话号码）|

> 实际应用建议：
    - 现代JS引擎中，Array.sort()通常使用混合策略：
        - 小数组 → 插入排序
        - 大数组 → 快速排序/归并排序
    - 在数据为整数且范围有限时，优先考虑计数排序/基数排序
